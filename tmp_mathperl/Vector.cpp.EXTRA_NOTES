// GENERATED BY INLINE, EXAMPLE OBJECT CONSTRUCTOR CODE, C++ TO PERL
    XS_EUPXS(XS_MathPerl__DataStructure__Vector_new); /* prototype to pass -Wmissing-prototypes */
    XS_EUPXS(XS_MathPerl__DataStructure__Vector_new)
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
    char *  CLASS = (char *)SvPV_nolen(ST(0))
;
    MathPerl__DataStructure__Vector *   RETVAL;

    RETVAL = new MathPerl__DataStructure__Vector();
    ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);

// GENERATED BY INLINE, EXAMPLE OBJECT ACCEPTING CODE, PERL TO C++
    XS_EUPXS(XS_main_MathPerl__DataStructure__Vector__Vector_to_string); /* prototype to pass -Wmissing-prototypes */
    XS_EUPXS(XS_main_MathPerl__DataStructure__Vector__Vector_to_string)
    {
        dVAR; dXSARGS;
        if (items != 1)
           croak_xs_usage(cv,  "input_vector_rawptr");
        {
        MathPerl__DataStructure__Vector *   input_vector_rawptr;
        string  RETVAL;

        // WBRASWELL 20160614 2016.166: add debugging statements
        //printf ( "in main::MathPerl__DataStructure__Vector__Vector_to_string(), have sv_isobject(ST(0)) = %d ENDOFLINE ", sv_isobject(ST(0)) );
        //printf ( "in main::MathPerl__DataStructure__Vector__Vector_to_string(), have (SvTYPE(SvRV(ST(0))) = %d ENDOFLINE ", SvTYPE(SvRV(ST(0))));
        //printf ( "in main::MathPerl__DataStructure__Vector__Vector_to_string(), have SVt_PVMG = %d ENDOFLINE ", SVt_PVMG);
        //printf ( "in main::MathPerl__DataStructure__Vector__Vector_to_string(), have SVt_PVAV = %d ENDOFLINE ", SVt_PVAV);
        //printf ( "in main::MathPerl__DataStructure__Vector__Vector_to_string(), have SVt_PVHV = %d ENDOFLINE ", SVt_PVHV);
        if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
            input_vector_rawptr = (MathPerl__DataStructure__Vector *)SvIV((SV*)SvRV( ST(0) ));
        }
        else {
            warn ( "main::MathPerl__DataStructure__Vector__Vector_to_string() -- input_vector_rawptr is not a blessed reference" );
            XSRETURN_UNDEF;
        }
    ;

        RETVAL = MathPerl__DataStructure__Vector__Vector_to_string(input_vector_rawptr);
        ST(0) = sv_newmortal();
        XS_pack_string(ST(0), RETVAL);
        }
        XSRETURN(1);
    }


// GENERATED BY WILL, FROM PERLXSTYPEMAP DOCS
# Perl to C++
INPUT
T_PTROBJ_SPECIAL
    croak('"in typemap.rperl, INPUT T_PTROBJ_SPECIAL, have var = $var CROAKING!!!\");
    if (sv_derived_from($arg, \"${(my $ntt=$ntype)=~s/__/::/g;\$ntt}\")) {
        IV tmp = SvIV((SV*)SvRV($arg));
        $var = ($type) tmp;
    } else {
        croak(\"$var is not of type ${(my $ntt=$ntype)=~s/__/::/g;\$ntt}\");
    }

# C++ to Perl
OUTPUT
T_PTROBJ_SPECIAL
    croak('"in typemap.rperl, OUTPUT T_PTROBJ_SPECIAL, have var = $var CROAKING!!!\");
    sv_setref_pv($arg, \"${(my $ntt=$ntype)=~s/__/::/g;\$ntt}\", (void *) $var);


// GENERATED BY WILL, EXAMPLE ACCESSOR/MUTATOR CODE
// CALLED INDIRECTLY FROM PERL SHIM, CREATE NEW PERL OBJECT
    PhysicsPerl__Astro__Body_ptr& get_bodies_element(integer i) { return this->bodies[i]; }  // call from C++
    void get_bodies_element_indirect(integer i, PhysicsPerl__Astro__Body_rawptr bodies_element_rawptr) { *bodies_element_rawptr = *(this->bodies[i].get_raw()); }  // call from Perl shim
    void set_bodies_element(integer i, PhysicsPerl__Astro__Body_ptr& bodies_element_ptr) { *(this->bodies[i].get_raw()) = *(bodies_element_ptr.get_raw()); }  // call from C++
    void set_bodies_element(integer i, PhysicsPerl__Astro__Body_rawptr bodies_element_rawptr) { *(this->bodies[i].get_raw()) = *bodies_element_rawptr; }  // call from Perl


// GENERATED BY WILL, EXAMPLE ARRAYREF UNPACK CODE
    AV* output_av = newAV();  // initialize output array to empty
    integer input_vector_length = input_vector.size();
    integer i;
    SV* temp_sv_pointer;

//  fprintf(stderr, "in CPPOPS_CPPTYPES XS_pack_MathPerl__DataStructure__Vector(), have input_vector_length = %ld\n", input_vector_length);

    if (input_vector_length > 0) { for (i = 0;  i < input_vector_length;  ++i) { av_push(output_av, newSVnv(input_vector[i])); } }
//  else warn("in CPPOPS_CPPTYPES XS_pack_MathPerl__DataStructure__Vector(), array was empty, returning empty array via newAV()");

    temp_sv_pointer = newSVrv(output_avref, NULL);    // upgrade output stack SV to an RV
    SvREFCNT_dec(temp_sv_pointer);       // discard temporary pointer
    SvRV(output_avref) = (SV*)output_av;       // make output stack RV pointer at our output AV


