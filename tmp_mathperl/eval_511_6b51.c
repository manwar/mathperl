/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of eval_511_6b51.xs. Do not edit this file, edit eval_511_6b51.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "eval_511_6b51.xs"

#define __INLINE_CPP_STANDARD_HEADERS 1
#define __INLINE_CPP_NAMESPACE_STD 1


#define __INLINE_CPP_STANDARD_HEADERS 1
#define __INLINE_CPP_NAMESPACE_STD 1

#define __INLINE_CPP 1
#ifndef bool
#include <iostream>
#endif
extern "C" {
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "INLINE.h"
}
#ifdef bool
#undef bool
#include <iostream>
#endif

#include <memory>
#include <iostream>
#include <string>
#include <sstream>
#include <limits>
#undef seed
#include <algorithm>
#include <vector>
#include <math.h>
#include <unordered_map>
# 1 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/_Inline/build/eval_511_6b51/Filters27149.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/_Inline/build/eval_511_6b51/Filters27149.c"

using std::cout; using std::cerr; using std::endl;





# 1 "lib/MathPerl/LinearAlgebra/AddVectorVector.h" 1

using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl.cpp" 1



# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl.h" 1

using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes_mode.h" 1
# 9 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 1




# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/HelperFunctions.cpp" 1



# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/HelperFunctions.h" 1
# 24 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/HelperFunctions.h"
int RPerl_SvBOKp(SV* input_sv);
int RPerl_SvUIOKp(SV* input_sv);
int RPerl_SvIOKp(SV* input_sv);
int RPerl_SvNOKp(SV* input_sv);
int RPerl_SvCOKp(SV* input_sv);
int RPerl_SvPOKp(SV* input_sv);
int RPerl_SvAROKp(SV* input_avref);
int RPerl_SvHROKp(SV* input_hv_ref);

void RPerl_object_property_init(SV* initee);





int RPerl__HelperFunctions__MODE_ID() { return 2; }
# 5 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/HelperFunctions.cpp" 2


int RPerl_SvBOKp(SV* input_sv) { return((SvIOK(input_sv) && ((SvIV(input_sv) == 0) || (SvIV(input_sv) == 1)))); }
int RPerl_SvUIOKp(SV* input_sv) { return((SvIOK(input_sv) && (SvIV(input_sv) >= 0))); }
int RPerl_SvIOKp(SV* input_sv) { return(SvIOKp(input_sv)); }
int RPerl_SvNOKp(SV* input_sv) { return(SvNOKp(input_sv)); }
int RPerl_SvCOKp(SV* input_sv) { return((SvPOK(input_sv) && (strlen((char*) SvPV_nolen(input_sv)) == 1))); }
int RPerl_SvPOKp(SV* input_sv) { return(SvPOKp(input_sv)); }
int RPerl_SvAROKp(SV* input_avref) { return((SvROK(input_avref) && (SvTYPE(SvRV(input_avref)) == SVt_PVAV))); }
int RPerl_SvHROKp(SV* input_hv_ref) { return((SvROK(input_hv_ref) && (SvTYPE(SvRV(input_hv_ref)) == SVt_PVHV))); }



void RPerl_object_property_init(SV* initee)
{
 dSP;
 PUSHMARK(SP);
 XPUSHs(initee);
 PUTBACK;
 call_pv("Dumper", G_SCALAR);

}
# 6 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2

# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 1
using std::cout; using std::cerr; using std::endl;






# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.h" 1
using std::cout; using std::cerr; using std::endl;
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.h"
typedef bool boolean;





typedef unsigned long int unsigned_integer;



typedef long int integer;



typedef double number;



typedef char character;



typedef std::string string;
typedef std::ostringstream ostringstream;
# 58 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.h"
int RPerl__DataType__Boolean__MODE_ID() { return 2; }







boolean XS_unpack_boolean(SV* input_sv);
void XS_pack_boolean(SV* output_sv, boolean input_boolean);






unsigned_integer boolean_to_unsigned_integer(boolean input_boolean);






integer boolean_to_integer(boolean input_boolean);






number boolean_to_number(boolean input_boolean);






character boolean_to_character(boolean input_boolean);






string boolean_to_string(boolean input_boolean);







boolean boolean__typetest0();
boolean boolean__typetest1(boolean lucky_boolean);
# 9 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 1
using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.h" 1
using std::cout; using std::cerr; using std::endl;
# 56 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.h"
int RPerl__DataType__UnsignedInteger__MODE_ID() { return 2; }







unsigned_integer XS_unpack_unsigned_integer(SV* input_sv);
void XS_pack_unsigned_integer(SV* output_sv, unsigned_integer input_unsigned_integer);






boolean unsigned_integer_to_boolean(unsigned_integer input_unsigned_integer);






integer unsigned_integer_to_integer(unsigned_integer input_unsigned_integer);






number unsigned_integer_to_number(unsigned_integer input_unsigned_integer);






character unsigned_integer_to_character(unsigned_integer input_unsigned_integer);






string unsigned_integer_to_string(unsigned_integer input_unsigned_integer);

string unsigned_integer_to_string_CPPTYPES(unsigned_integer input_unsigned_integer);






unsigned_integer unsigned_integer__typetest0();
unsigned_integer unsigned_integer__typetest1(unsigned_integer lucky_unsigned_integer);
# 8 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 9 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.h" 1
using std::cout; using std::cerr; using std::endl;
# 63 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.h"
int RPerl__DataType__Integer__MODE_ID() { return 2; }







integer XS_unpack_integer(SV* input_sv);
void XS_pack_integer(SV* output_sv, integer input_integer);






boolean integer_to_boolean(integer input_integer);






unsigned_integer integer_to_unsigned_integer(integer input_integer);






number integer_to_number(integer input_integer);






character integer_to_character(integer input_integer);






string integer_to_string(integer input_integer);

string integer_to_string_CPPTYPES(integer input_integer);






integer integer__typetest0();
integer integer__typetest1(integer lucky_integer);
# 8 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 9 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.h" 1
using std::cout; using std::cerr; using std::endl;
# 61 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.h"
int RPerl__DataType__Number__MODE_ID() { return 2; }







number XS_unpack_number(SV* input_sv);
void XS_pack_number(SV* output_sv, number input_number);






boolean number_to_boolean(number input_number);






unsigned_integer number_to_unsigned_integer(number input_number);






integer number_to_integer(number input_number);






character number_to_character(number input_number);






string number_to_string(number input_number);


string number_to_string_CPPTYPES(number input_number);






number number__typetest0();
number number__typetest1(number lucky_number);
# 8 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 9 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 1
using std::cout; using std::cerr; using std::endl;






# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.h" 1
using std::cout; using std::cerr; using std::endl;
# 58 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.h"
int RPerl__DataType__Character__MODE_ID() { return 2; }







character XS_unpack_character(SV* input_sv);
void XS_pack_character(SV* output_sv, character input_character);






boolean character_to_boolean(character input_character);






unsigned_integer character_to_unsigned_integer(character input_character);






integer character_to_integer(character input_character);






number character_to_number(character input_character);






string character_to_string(character input_character);







character character__typetest0();
character character__typetest1(character lucky_character);
# 9 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 12 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.h" 1
using std::cout; using std::cerr; using std::endl;
# 61 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.h"
int RPerl__DataType__String__MODE_ID() { return 2; }







string XS_unpack_string(SV* input_sv);
void XS_pack_string(SV* output_sv, string input_string);






void string_substitute_global(string& input_string, const string& find_string, const string& replace_string);






boolean string_to_boolean(string input_string);






unsigned_integer string_to_unsigned_integer(string input_string);






integer string_to_integer(string input_string);






number string_to_number(string input_string);






character string_to_character(string input_string);






string string_to_string(string input_string);







string string__typetest0();
string string__typetest1(string lucky_string);
# 8 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 9 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 12 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 2
# 48 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
string XS_unpack_string(SV* input_sv)
{


 (not(SvOK(input_sv)) ? croak("\nERROR EPV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_string()") : (not(SvPOKp(input_sv)) ? croak("\nERROR EPV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring value expected but non-string value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_string()") : (void)0));



 return((string)SvPV_nolen(input_sv));

}


void XS_pack_string(SV* output_sv, string input_string) {



 sv_setsv(output_sv, sv_2mortal(newSVpv(input_string.data(), input_string.size())));



}
# 87 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
void string_substitute_global(string& input_string, const string& find_string, const string& replace_string) {
    size_t found_position = 0;
    while ((found_position = input_string.find(find_string, found_position)) != string::npos) {
         input_string.replace(found_position, find_string.length(), replace_string);
         found_position += replace_string.length();
    }
}
# 113 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
boolean string_to_boolean(string input_string) {
    string_substitute_global(input_string, "_", "");
    if (atoi(input_string.c_str()) == 0) { return 0; }
    else { return 1; }
}
# 137 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
unsigned_integer string_to_unsigned_integer(string input_string) {
    string_substitute_global(input_string, "_", "");
    if (atoi(input_string.c_str()) < 0) { return (unsigned_integer) (atoi(input_string.c_str()) * -1); }
    else { return (unsigned_integer) atoi(input_string.c_str()); }
}
# 160 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
integer string_to_integer(string input_string) {
    string_substitute_global(input_string, "_", "");
    return (integer) atoi(input_string.c_str());
}
# 182 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
number string_to_number(string input_string) {
    string_substitute_global(input_string, "_", "");
    return (number) atof(input_string.c_str());
}
# 203 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
character string_to_character(string input_string) {
    return (character) input_string.at(0);
}
# 252 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
string string_to_string(string input_string)
{



    size_t input_string_pos;


 input_string_pos = 0;
 while((input_string_pos = input_string.find("\\", input_string_pos)) != string::npos)
 {
  input_string.replace(input_string_pos, 1, "\\\\");
  input_string_pos += 2;
 }
 input_string_pos = 0;
 while((input_string_pos = input_string.find("'", input_string_pos)) != string::npos)
 {
  input_string.replace(input_string_pos, 1, "\\'");
  input_string_pos += 2;
 }

 input_string = "'" + input_string + "'";



 return(input_string);
}
# 304 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp"
string string__typetest0() {
 string retval = "Spice CPPOPS_CPPTYPES";

 return retval;
}

string string__typetest1(string lucky_string) {

 return(string_to_string(lucky_string) + " CPPOPS_CPPTYPES");
}
# 14 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 2
# 23 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp"
character XS_unpack_character(SV* input_sv) {

 (not(SvOK(input_sv)) ? croak("\nERROR ETV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ncharacter value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_character()") : (not((SvPOK(input_sv) && (strlen((char*) SvPV_nolen(input_sv)) == 1))) ? croak("\nERROR ETV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ncharacter value expected but non-character value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_character()") : (void)0));
 return((character) (SvPV_nolen(input_sv))[1]);
}


void XS_pack_character(SV* output_sv, character input_character) {



 sv_setsv(output_sv, sv_2mortal(newSVpvf("%c", input_character)));



}
# 56 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp"
boolean character_to_boolean(character input_character) {
    if ((input_character - '0') == 0) { return 0; }
    else { return 1; }
}
# 77 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp"
unsigned_integer character_to_unsigned_integer(character input_character) {
    return (unsigned_integer) (input_character - '0');
}
# 97 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp"
integer character_to_integer(character input_character) {
    return (integer) (input_character - '0');
}
# 117 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp"
number character_to_number(character input_character) {
    return (number) (input_character - '0');
}
# 138 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp"
string character_to_string(character input_character) {
    string retval(1, input_character);
    return retval;
}
# 164 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp"
character character__typetest0() {
 return (RPerl__DataType__Character__MODE_ID() + '0');
}

character character__typetest1(character lucky_character) {
    return (lucky_character + RPerl__DataType__Character__MODE_ID());
}
# 12 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 2
# 48 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp"
number XS_unpack_number(SV* input_sv) {


 (not(SvOK(input_sv)) ? croak("\nERROR ENV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_number()") : (not(SvNOKp(input_sv) || SvIOKp(input_sv)) ? croak("\nERROR ENV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber value expected but non-number value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_number()") : (void)0));
# 60 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp"
 return (number)SvNV(input_sv);

}


void XS_pack_number(SV* output_sv, number input_number) {



 sv_setsv(output_sv, sv_2mortal(newSVnv(input_number)));



}
# 98 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp"
boolean number_to_boolean(number input_number) {
    if (input_number == 0) { return (boolean) input_number; }
    else { return 1; }
}
# 120 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp"
unsigned_integer number_to_unsigned_integer(number input_number) {
    if (input_number < 0) { return (unsigned_integer) (input_number * -1); }
    else { return (unsigned_integer) input_number; }
}
# 141 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp"
integer number_to_integer(number input_number) {
    return (integer) floor(input_number);
}
# 161 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp"
character number_to_character(number input_number) {

    return (character) number_to_string_CPPTYPES(input_number).at(0);
}
# 200 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp"
string number_to_string(number input_number) {
    return number_to_string_CPPTYPES(input_number);
}






string number_to_string_CPPTYPES(number input_number)
{



    std::ostringstream output_stream;
    output_stream.precision(std::numeric_limits<double>::digits10);
    output_stream << input_number;




    boolean is_negative = 0;
    if (input_number < 0) { is_negative = 1; }

    string input_number_stringified = output_stream.str();

    std::stringstream input_number_stringified_stream(input_number_stringified);
    string whole_part;
    std::getline(input_number_stringified_stream, whole_part, '.');
    string decimal_part;
    std::getline(input_number_stringified_stream, decimal_part, '.');




    std::reverse(whole_part.begin(), whole_part.end());


    if (is_negative) { whole_part.pop_back(); }

    string whole_part_underscores = "";
    for(std::string::size_type i = 0; i < whole_part.size(); ++i) {

        whole_part_underscores += whole_part[i];
        if (((i % 3) == 2) && (i > 0) && (i != (whole_part.size() - 1))) {

            whole_part_underscores += '_';
        }
    }



    std::reverse(whole_part_underscores.begin(), whole_part_underscores.end());

    if (whole_part_underscores == "") {
        whole_part_underscores = "0";
    }



    string decimal_part_underscores = "";
    for(std::string::size_type i = 0; i < decimal_part.size(); ++i) {

        decimal_part_underscores += decimal_part[i];
        if (((i % 3) == 2) && (i > 0) && (i != (decimal_part.size() - 1))) {

            decimal_part_underscores += '_';
        }
    }

    if (decimal_part_underscores != "") {
        whole_part_underscores += '.' + decimal_part_underscores;
    }

    if (is_negative) { whole_part_underscores = '-' + whole_part_underscores; }

    return whole_part_underscores;
}
# 300 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp"
number number__typetest0() {
 number retval = (22.0 / 7.0) + RPerl__DataType__Number__MODE_ID();

 return retval;
}

number number__typetest1(number lucky_number) {

 return (lucky_number * 2.0) + RPerl__DataType__Number__MODE_ID();
}
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 12 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 2
# 48 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp"
integer XS_unpack_integer(SV* input_sv) {


 (not(SvOK(input_sv)) ? croak("\nERROR EIV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_integer()") : (not(SvIOKp(input_sv)) ? croak("\nERROR EIV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger value expected but non-integer value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_integer()") : (void)0));
# 60 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp"
 return((integer)SvIV(input_sv));

}


void XS_pack_integer(SV* output_sv, integer input_integer) {



 sv_setsv(output_sv, sv_2mortal(newSViv(input_integer)));



}
# 92 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp"
boolean integer_to_boolean(integer input_integer) {
    if (input_integer == 0) { return (boolean) input_integer; }
    else { return 1; }
}
# 114 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp"
unsigned_integer integer_to_unsigned_integer(integer input_integer) {
    if (input_integer < 0) { return (unsigned_integer) (input_integer * -1); }
    else { return (unsigned_integer) input_integer; }
}
# 137 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp"
number integer_to_number(integer input_integer) { return (number) input_integer; }
# 155 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp"
character integer_to_character(integer input_integer) {

    return (character) integer_to_string_CPPTYPES(input_integer).at(0);
}
# 183 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp"
string integer_to_string(integer input_integer) {
    return(integer_to_string_CPPTYPES(input_integer));
}






string integer_to_string_CPPTYPES(integer input_integer)
{



    std::ostringstream output_stream;
    output_stream.precision(std::numeric_limits<double>::digits10);
    output_stream << input_integer;




    string output_string = output_stream.str();


    boolean is_negative = 0;
    if (input_integer < 0) { is_negative = 1; }

    std::reverse(output_string.begin(), output_string.end());


    if (is_negative) { output_string.pop_back(); }

    string output_string_underscores = "";
    for(std::string::size_type i = 0; i < output_string.size(); ++i) {

        output_string_underscores += output_string[i];
        if (((i % 3) == 2) && (i > 0) && (i != (output_string.size() - 1))) {

            output_string_underscores += '_';
        }
    }



    std::reverse(output_string_underscores.begin(), output_string_underscores.end());

    if (output_string_underscores == "") {
        output_string_underscores = "0";
    }



    if (is_negative) { output_string_underscores = '-' + output_string_underscores; }

    return output_string_underscores;
}
# 261 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp"
integer integer__typetest0() {
 integer retval = (21 / 7) + RPerl__DataType__Integer__MODE_ID();

 return retval;
}

integer integer__typetest1(integer lucky_integer) {

 return (lucky_integer * 2) + RPerl__DataType__Integer__MODE_ID();
}
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 12 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 2
# 22 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp"
unsigned_integer XS_unpack_unsigned_integer(SV* input_sv) {


 (not(SvOK(input_sv)) ? croak("\nERROR EUV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nunsigned_integer value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_unsigned_integer()") : (not((SvIOK(input_sv) && (SvIV(input_sv) >= 0))) ? croak("\nERROR EUV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nunsigned_integer value expected but non-unsigned_integer value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_unsigned_integer()") : (void)0));
# 34 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp"
 return((unsigned_integer)SvIV(input_sv));

}


void XS_pack_unsigned_integer(SV* output_sv, unsigned_integer input_unsigned_integer) {



 sv_setsv(output_sv, sv_2mortal(newSViv(input_unsigned_integer)));



}
# 66 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp"
boolean unsigned_integer_to_boolean(unsigned_integer input_unsigned_integer) {
    if (input_unsigned_integer == 0) { return (boolean) input_unsigned_integer; }
    else { return 1; }
}
# 88 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp"
integer unsigned_integer_to_integer(unsigned_integer input_unsigned_integer) {
    if (input_unsigned_integer < 0) { return (integer) (input_unsigned_integer * -1); }
    else { return (integer) input_unsigned_integer; }
}
# 109 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp"
number unsigned_integer_to_number(unsigned_integer input_unsigned_integer) {
    return (number) input_unsigned_integer;
}
# 129 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp"
character unsigned_integer_to_character(unsigned_integer input_unsigned_integer) {

    return (character) unsigned_integer_to_string_CPPTYPES(input_unsigned_integer).at(0);
}
# 157 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp"
string unsigned_integer_to_string(unsigned_integer input_unsigned_integer) {
    return(unsigned_integer_to_string_CPPTYPES(input_unsigned_integer));
}






string unsigned_integer_to_string_CPPTYPES(unsigned_integer input_unsigned_integer)
{



    std::ostringstream output_stream;
    output_stream.precision(std::numeric_limits<double>::digits10);
    output_stream << input_unsigned_integer;




    string output_string = output_stream.str();


    boolean is_negative = 0;
    if (input_unsigned_integer < 0) { is_negative = 1; }

    std::reverse(output_string.begin(), output_string.end());


    if (is_negative) { output_string.pop_back(); }

    string output_string_underscores = "";
    for(std::string::size_type i = 0; i < output_string.size(); ++i) {

        output_string_underscores += output_string[i];
        if (((i % 3) == 2) && (i > 0) && (i != (output_string.size() - 1))) {

            output_string_underscores += '_';
        }
    }



    std::reverse(output_string_underscores.begin(), output_string_underscores.end());

    if (output_string_underscores == "") {
        output_string_underscores = "0";
    }



    if (is_negative) { output_string_underscores = '-' + output_string_underscores; }

    return output_string_underscores;
}
# 235 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp"
unsigned_integer unsigned_integer__typetest0() {
 unsigned_integer retval = (21 / 7) + RPerl__DataType__UnsignedInteger__MODE_ID();

 return retval;
}

unsigned_integer unsigned_integer__typetest1(unsigned_integer lucky_unsigned_integer) {

 return (lucky_unsigned_integer * 2) + RPerl__DataType__UnsignedInteger__MODE_ID();
}
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 12 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 14 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp" 2
# 23 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp"
boolean XS_unpack_boolean(SV* input_sv) {


 (not(SvOK(input_sv)) ? croak("\nERROR EBV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nboolean value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_boolean()") : (not((SvIOK(input_sv) && ((SvIV(input_sv) == 0) || (SvIV(input_sv) == 1)))) ? croak("\nERROR EBV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nboolean value expected but non-boolean value found,\nin variable %s from subroutine %s,\ncroaking", "input_sv", "XS_unpack_boolean()") : (void)0));
# 35 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp"
 return((boolean)SvIV(input_sv));

}


void XS_pack_boolean(SV* output_sv, boolean input_boolean) {



 sv_setsv(output_sv, sv_2mortal(newSViv(input_boolean)));



}
# 66 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp"
unsigned_integer boolean_to_unsigned_integer(boolean input_boolean) {
    return (unsigned_integer) input_boolean;
}
# 86 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp"
integer boolean_to_integer(boolean input_boolean) {
    return (integer) input_boolean;
}
# 106 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp"
number boolean_to_number(boolean input_boolean) {
    return (number) input_boolean;
}
# 126 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp"
character boolean_to_character(boolean input_boolean) {
    return (character) boolean_to_string(input_boolean).at(0);
}
# 149 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp"
string boolean_to_string(boolean input_boolean) {
    std::ostringstream output_stream;
    output_stream << input_boolean;
    return(output_stream.str());
}
# 184 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Boolean.cpp"
boolean boolean__typetest0() {

 boolean retval = 1;
 if (RPerl__DataType__Boolean__MODE_ID() == 0) { retval = 0; }

 return retval;
}

boolean boolean__typetest1(boolean lucky_boolean) {

    boolean retval = 1;
    if ((lucky_boolean + RPerl__DataType__Boolean__MODE_ID()) == 0) { retval = 0; }

 return retval;

}
# 8 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/UnsignedInteger.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 9 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Character.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 12 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.cpp" 1
using std::cout; using std::cerr; using std::endl; using std::to_string;




# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.h" 1

using std::cout; using std::cerr; using std::endl;







# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.cpp" 1
using std::cout; using std::cerr; using std::endl; using std::to_string;




# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.h" 1

using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.h"
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 14 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 15 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 16 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.h" 2


typedef std::vector<integer> integer_arrayref;
typedef std::vector<integer>::iterator integer_arrayref_iterator;
typedef std::vector<integer>::const_iterator integer_arrayref_const_iterator;
typedef std::vector<number> number_arrayref;
typedef std::vector<number>::iterator number_arrayref_iterator;
typedef std::vector<number>::const_iterator number_arrayref_const_iterator;
typedef std::vector<string> string_arrayref;
typedef std::vector<string>::iterator string_arrayref_iterator;
typedef std::vector<string>::const_iterator string_arrayref_const_iterator;


typedef std::vector<std::vector<integer>> integer_arrayref_arrayref;
typedef std::vector<std::vector<integer>>::iterator integer_arrayref_arrayref_iterator;
typedef std::vector<std::vector<integer>>::const_iterator integer_arrayref_arrayref_const_iterator;
typedef std::vector<std::vector<number>> number_arrayref_arrayref;
typedef std::vector<std::vector<number>>::iterator number_arrayref_arrayref_iterator;
typedef std::vector<std::vector<number>>::const_iterator number_arrayref_arrayref_const_iterator;
typedef std::vector<std::vector<string>> string_arrayref_arrayref;
typedef std::vector<std::vector<string>>::iterator string_arrayref_arrayref_iterator;
typedef std::vector<std::vector<string>>::const_iterator string_arrayref_arrayref_const_iterator;


void integer_arrayref_arrayref_CHECK(SV* possible_integer_arrayref_arrayref);
void integer_arrayref_arrayref_CHECKTRACE(SV* possible_integer_arrayref_arrayref, const char* variable_name, const char* subroutine_name);
void number_arrayref_arrayref_CHECK(SV* possible_number_arrayref_arrayref);
void number_arrayref_arrayref_CHECKTRACE(SV* possible_number_arrayref_arrayref, const char* variable_name, const char* subroutine_name);
void string_arrayref_arrayref_CHECK(SV* possible_string_arrayref_arrayref);
void string_arrayref_arrayref_CHECKTRACE(SV* possible_string_arrayref_arrayref, const char* variable_name, const char* subroutine_name);





integer RPerl__DataStructure__Array__SubTypes__MODE_ID() { return 2; }






integer_arrayref_arrayref XS_unpack_integer_arrayref_arrayref(SV* input_avref_avref);
void XS_pack_integer_arrayref_arrayref(SV* output_avref_avref, integer_arrayref_arrayref input_vector_vector);
number_arrayref_arrayref XS_unpack_number_arrayref_arrayref(SV* input_avref_avref);
void XS_pack_number_arrayref_arrayref(SV* output_avref_avref, number_arrayref_arrayref input_vector_vector);
string_arrayref_arrayref XS_unpack_string_arrayref_arrayref(SV* input_avref_avref);
void XS_pack_string_arrayref_arrayref(SV* output_avref_avref, string_arrayref_arrayref input_vector_vector);
# 72 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.h"
string integer_arrayref_arrayref_to_string(integer_arrayref_arrayref input_vector_vector);
string number_arrayref_arrayref_to_string(number_arrayref_arrayref input_vector_vector);
string string_arrayref_arrayref_to_string(string_arrayref_arrayref input_vector_vector);
# 86 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.h"
string integer_arrayref_arrayref__typetest0(integer_arrayref_arrayref lucky_integers);
integer_arrayref_arrayref integer_arrayref_arrayref__typetest1(integer my_size);
string number_arrayref_arrayref__typetest0(number_arrayref_arrayref lucky_numbers);
number_arrayref_arrayref number_arrayref_arrayref__typetest1(integer my_size);
string string_arrayref_arrayref__typetest0(string_arrayref_arrayref people);
string_arrayref_arrayref string_arrayref_arrayref__typetest1(integer my_size);
# 7 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.cpp" 2





void integer_arrayref_arrayref_CHECK(SV* possible_integer_arrayref_arrayref)
{
 fprintf(stderr, "in CPPOPS_CPPTYPES integer_arrayref_arrayref_CHECK(), top of subroutine\n");

    if ( not( SvOK(possible_integer_arrayref_arrayref) ) ) { croak( "\nERROR EIVAVRVAVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref_arrayref value expected but undefined/null value found,\ncroaking" ); }
    if ( not( (SvROK(possible_integer_arrayref_arrayref) && (SvTYPE(SvRV(possible_integer_arrayref_arrayref)) == SVt_PVAV)) ) ) { croak( "\nERROR EIVAVRVAVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref_arrayref value expected but non-arrayref value found,\ncroaking" ); }

    AV* possible_integer_arrayref_array;
    integer possible_integer_arrayref_array_length;
    integer i;
    SV** possible_integer_arrayref_array_element;

    possible_integer_arrayref_array = (AV*)SvRV(possible_integer_arrayref_arrayref);
 possible_integer_arrayref_array_length = av_len(possible_integer_arrayref_array) + 1;

 for (i = 0; i < possible_integer_arrayref_array_length; ++i)
 {
  possible_integer_arrayref_array_element = av_fetch(possible_integer_arrayref_array, i, 0);
  if ( not( SvOK(*possible_integer_arrayref_array_element) ) ) { croak( "\nERROR EIVAVRVAVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref_arrayref sub-arrayref value expected but undefined/null value found at index %ld,\ncroaking", i ); }
  if ( not( (SvROK(*possible_integer_arrayref_array_element) && (SvTYPE(SvRV(*possible_integer_arrayref_array_element)) == SVt_PVAV)) ) ) { croak( "\nERROR EIVAVRVAVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref_arrayref sub-arrayref value expected but non-arrayref value found at index %ld,\ncroaking", i ); }

  SV* possible_integer_arrayref = *possible_integer_arrayref_array_element;

     AV* possible_integer_array;
     integer possible_integer_array_length;
     integer j;
     SV** possible_integer_array_element;

     possible_integer_array = (AV*)SvRV(possible_integer_arrayref);
     possible_integer_array_length = av_len(possible_integer_array) + 1;

     for (j = 0; j < possible_integer_array_length; ++j)
     {
         possible_integer_array_element = av_fetch(possible_integer_array, j, 0);
         if (not(SvOK(*possible_integer_array_element))) { croak("\nERROR EIVAVRVAVRV04, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref element value expected but undefined/null value found at index (%ld, %ld),\ncroaking", i, j); }
         if (not(SvIOKp(*possible_integer_array_element))) { croak("\nERROR EIVAVRVAVRV05, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref element value expected but non-integer value found at index (%ld, %ld),\ncroaking", i, j); }
     }
 }
 fprintf(stderr, "in CPPOPS_CPPTYPES integer_arrayref_arrayref_CHECK(), bottom of subroutine\n");
}

void integer_arrayref_arrayref_CHECKTRACE(SV* possible_integer_arrayref_arrayref, const char* variable_name, const char* subroutine_name)
{
 fprintf(stderr, "in CPPOPS_CPPTYPES integer_arrayref_arrayref_CHECKTRACE(), top of subroutine, received variable_name = %s\n", variable_name);
 fprintf(stderr, "in CPPOPS_CPPTYPES integer_arrayref_arrayref_CHECKTRACE(), top of subroutine, received subroutine_name = %s\n", subroutine_name);

    if ( not( SvOK(possible_integer_arrayref_arrayref) ) ) { croak( "\nERROR EIVAVRVAVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref_arrayref value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }
    if ( not( (SvROK(possible_integer_arrayref_arrayref) && (SvTYPE(SvRV(possible_integer_arrayref_arrayref)) == SVt_PVAV)) ) ) { croak( "\nERROR EIVAVRVAVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref_arrayref value expected but non-arrayref value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }

    AV* possible_integer_arrayref_array;
    integer possible_integer_arrayref_array_length;
    integer i;
    SV** possible_integer_arrayref_array_element;

    possible_integer_arrayref_array = (AV*)SvRV(possible_integer_arrayref_arrayref);
    possible_integer_arrayref_array_length = av_len(possible_integer_arrayref_array) + 1;

    for (i = 0; i < possible_integer_arrayref_array_length; ++i)
    {
        possible_integer_arrayref_array_element = av_fetch(possible_integer_arrayref_array, i, 0);
        if ( not( SvOK(*possible_integer_arrayref_array_element) ) ) { croak( "\nERROR EIVAVRVAVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref_arrayref sub-arrayref value expected but undefined/null value found at index %ld,\nin variable %s from subroutine %s,\ncroaking", i, variable_name, subroutine_name ); }
        if ( not( (SvROK(*possible_integer_arrayref_array_element) && (SvTYPE(SvRV(*possible_integer_arrayref_array_element)) == SVt_PVAV)) ) ) { croak( "\nERROR EIVAVRVAVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref_arrayref sub-arrayref value expected but non-arrayref value found at index %ld,\nin variable %s from subroutine %s,\ncroaking", i, variable_name, subroutine_name ); }

        SV* possible_integer_arrayref = *possible_integer_arrayref_array_element;

        AV* possible_integer_array;
        integer possible_integer_array_length;
        integer j;
        SV** possible_integer_array_element;

        possible_integer_array = (AV*)SvRV(possible_integer_arrayref);
        possible_integer_array_length = av_len(possible_integer_array) + 1;

        for (j = 0; j < possible_integer_array_length; ++j)
        {
            possible_integer_array_element = av_fetch(possible_integer_array, j, 0);
            if (not(SvOK(*possible_integer_array_element))) { croak("\nERROR EIVAVRVAVRV04, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref element value expected but undefined/null value found at index (%ld, %ld),\nin variable %s from subroutine %s,\ncroaking", i, j, variable_name, subroutine_name ); }
            if (not(SvIOKp(*possible_integer_array_element))) { croak("\nERROR EIVAVRVAVRV05, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref element value expected but non-integer value found at index (%ld, %ld),\nin variable %s from subroutine %s,\ncroaking", i, j, variable_name, subroutine_name ); }
        }
    }
 fprintf(stderr, "in CPPOPS_CPPTYPES integer_arrayref_arrayref_CHECKTRACE(), bottom of subroutine\n");
}
# 102 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array/SubTypes.cpp"
integer_arrayref_arrayref XS_unpack_integer_arrayref_arrayref(SV* input_avref_avref)
{
 fprintf(stderr, "in CPPOPS_CPPTYPES XS_unpack_integer_arrayref_arrayref(), top of subroutine\n");

 integer_arrayref_arrayref_CHECKTRACE(input_avref_avref, "input_avref_avref", "XS_unpack_integer_arrayref_arrayref()");

    AV* input_avref_av;
    integer input_avref_av_length;
    integer i;
    SV** input_avref_av_element;
    integer_arrayref_arrayref output_vector_vector;

    input_avref_av = (AV*)SvRV(input_avref_avref);
 input_avref_av_length = av_len(input_avref_av) + 1;
 fprintf(stderr, "in CPPOPS_CPPTYPES XS_unpack_integer_arrayref_arrayref(), have input_avref_av_length = %ld\n", input_avref_av_length);



 output_vector_vector.resize((size_t)input_avref_av_length);

 for (i = 0; i < input_avref_av_length; ++i)
 {
     AV* input_av;
     integer input_av_length;
     integer j;
     SV** input_av_element;
     integer_arrayref output_vector;


     input_avref_av_element = av_fetch(input_avref_av, i, 0);


     input_av = (AV*)SvRV(*input_avref_av_element);
     input_av_length = av_len(input_av) + 1;
     fprintf(stderr, "in CPPOPS_CPPTYPES XS_unpack_integer_arrayref_arrayref(), have input_av_length = %ld\n", input_av_length);



     output_vector.resize((size_t)input_av_length);

     for (j = 0; j < input_av_length; ++j)
     {

         input_av_element = av_fetch(input_av, j, 0);


         output_vector[j] = SvIV(*input_av_element);
     }

     fprintf(stderr, "in CPPOPS_CPPTYPES XS_unpack_integer_arrayref_arrayref(), bottom of outer for() loop i = %ld, have output_vector.size() = %ld\n", i, (integer) output_vector.size());


     output_vector_vector[i] = output_vector;
 }

 fprintf(stderr, "in CPPOPS_CPPTYPES XS_unpack_integer_arrayref_arrayref(), after for() loop, have output_vector_vector.size() = %ld\n", (integer) output_vector_vector.size());
 fprintf(stderr, "in CPPOPS_CPPTYPES XS_unpack_integer_arrayref_arrayref(), bottom of subroutine\n");

 return(output_vector_vector);
}



void XS_pack_integer_arrayref_arrayref(SV* output_avref_avref, integer_arrayref_arrayref input_vector_vector)
{


 AV* output_avref_av = newAV();
 integer input_vector_vector_length = input_vector_vector.size();
 integer i;
 SV* temp_sv_pointer;



 if (input_vector_vector_length > 0) {
     for (i = 0; i < input_vector_vector_length; ++i) {

         integer_arrayref input_vector = input_vector_vector[i];

         AV* output_av = newAV();
         integer input_vector_length = input_vector.size();
         integer j;



         if (input_vector_length > 0) {
             for (j = 0; j < input_vector_length; ++j) {


                 av_push(output_av, newSViv(input_vector[j]));

             }
         }
         else warn("in CPPOPS_CPPTYPES XS_pack_integer_arrayref_arrayref(), sub-array was empty, returning empty sub-array via newAV()");


         av_push(output_avref_av, newRV_noinc((SV*)output_av));



     }
 }
 else warn("in CPPOPS_CPPTYPES XS_pack_integer_arrayref_arrayref(), array was empty, returning empty array via newAV()");

 temp_sv_pointer = newSVrv(output_avref_avref, NULL);
 SvREFCNT_dec(temp_sv_pointer);
 SvRV(output_avref_avref) = (SV*)output_avref_av;


}
# 11 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.h" 2





# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 17 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 18 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 19 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.h" 2
# 38 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.h"
typedef std::vector<integer> integer_arrayref;
typedef std::vector<integer>::iterator integer_arrayref_iterator;
typedef std::vector<integer>::const_iterator integer_arrayref_const_iterator;
typedef std::vector<number> number_arrayref;
typedef std::vector<number>::iterator number_arrayref_iterator;
typedef std::vector<number>::const_iterator number_arrayref_const_iterator;
typedef std::vector<string> string_arrayref;
typedef std::vector<string>::iterator string_arrayref_iterator;
typedef std::vector<string>::const_iterator string_arrayref_const_iterator;


void integer_arrayref_CHECK(SV* possible_integer_arrayref);
void integer_arrayref_CHECKTRACE(SV* possible_integer_arrayref, const char* variable_name, const char* subroutine_name);
void number_arrayref_CHECK(SV* possible_number_arrayref);
void number_arrayref_CHECKTRACE(SV* possible_number_arrayref, const char* variable_name, const char* subroutine_name);
void string_arrayref_CHECK(SV* possible_string_arrayref);
void string_arrayref_CHECKTRACE(SV* possible_string_arrayref, const char* variable_name, const char* subroutine_name);





integer RPerl__DataStructure__Array__MODE_ID() { return 2; }






integer_arrayref XS_unpack_integer_arrayref(SV* input_avref);
void XS_pack_integer_arrayref(SV* output_avref, integer_arrayref input_vector);
number_arrayref XS_unpack_number_arrayref(SV* input_avref);
void XS_pack_number_arrayref(SV* output_avref, number_arrayref input_vector);
string_arrayref XS_unpack_string_arrayref(SV* input_avref);
void XS_pack_string_arrayref(SV* output_avref, string_arrayref input_vector);
# 82 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.h"
string integer_arrayref_to_string(integer_arrayref input_vector);
string number_arrayref_to_string(number_arrayref input_vector);
string string_arrayref_to_string(string_arrayref input_vector);
# 98 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.h"
string integer_arrayref__typetest0(integer_arrayref lucky_integers);
integer_arrayref integer_arrayref__typetest1(integer my_size);
string number_arrayref__typetest0(number_arrayref lucky_numbers);
number_arrayref number_arrayref__typetest1(integer my_size);
string string_arrayref__typetest0(string_arrayref people);
string_arrayref string_arrayref__typetest1(integer my_size);
# 7 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.cpp" 2
# 22 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.cpp"
void integer_arrayref_CHECK(SV* possible_integer_arrayref)
{

    if ( not( SvOK(possible_integer_arrayref) ) ) { croak( "\nERROR EIVAVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref value expected but undefined/null value found,\ncroaking" ); }
    if ( not( (SvROK(possible_integer_arrayref) && (SvTYPE(SvRV(possible_integer_arrayref)) == SVt_PVAV)) ) ) { croak( "\nERROR EIVAVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref value expected but non-arrayref value found,\ncroaking" ); }

    AV* possible_integer_array;
    integer possible_integer_array_length;
    integer i;
    SV** possible_integer_array_element;

    possible_integer_array = (AV*)SvRV(possible_integer_arrayref);
 possible_integer_array_length = av_len(possible_integer_array) + 1;

 for (i = 0; i < possible_integer_array_length; ++i)
 {
  possible_integer_array_element = av_fetch(possible_integer_array, i, 0);


     if (not(SvOK(*possible_integer_array_element))) { croak("\nERROR EIVAVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref element value expected but undefined/null value found at index %ld,\ncroaking", i); }
  if (not(SvIOKp(*possible_integer_array_element))) { croak("\nERROR EIVAVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref element value expected but non-integer value found at index %ld,\ncroaking", i); }
 }
}

void integer_arrayref_CHECKTRACE(SV* possible_integer_arrayref, const char* variable_name, const char* subroutine_name)
{
    if ( not( SvOK(possible_integer_arrayref) ) ) { croak( "\nERROR EIVAVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }
    if ( not( (SvROK(possible_integer_arrayref) && (SvTYPE(SvRV(possible_integer_arrayref)) == SVt_PVAV)) ) ) { croak( "\nERROR EIVAVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref value expected but non-arrayref value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }

    AV* possible_integer_array;
    integer possible_integer_array_length;
    integer i;
    SV** possible_integer_array_element;

    possible_integer_array = (AV*)SvRV(possible_integer_arrayref);
 possible_integer_array_length = av_len(possible_integer_array) + 1;

 for (i = 0; i < possible_integer_array_length; ++i)
 {
  possible_integer_array_element = av_fetch(possible_integer_array, i, 0);

     if (not(SvOK(*possible_integer_array_element))) { croak("\nERROR EIVAVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref element value expected but undefined/null value found at index %ld,\nin variable %s from subroutine %s,\ncroaking", i, variable_name, subroutine_name); }
  if (not(SvIOKp(*possible_integer_array_element))) { croak("\nERROR EIVAVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_arrayref element value expected but non-integer value found at index %ld,\nin variable %s from subroutine %s,\ncroaking", i, variable_name, subroutine_name); }
 }
}

void number_arrayref_CHECK(SV* possible_number_arrayref)
{
    if ( not( SvOK(possible_number_arrayref) ) ) { croak( "\nERROR ENVAVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_arrayref value expected but undefined/null value found,\ncroaking" ); }
    if ( not( (SvROK(possible_number_arrayref) && (SvTYPE(SvRV(possible_number_arrayref)) == SVt_PVAV)) ) ) { croak( "\nERROR ENVAVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_arrayref value expected but non-arrayref value found,\ncroaking" ); }

    AV* possible_number_array;
    integer possible_number_array_length;
    integer i;
    SV** possible_number_array_element;

    possible_number_array = (AV*)SvRV(possible_number_arrayref);
 possible_number_array_length = av_len(possible_number_array) + 1;

 for (i = 0; i < possible_number_array_length; ++i)
 {
  possible_number_array_element = av_fetch(possible_number_array, i, 0);

     if (not(SvOK(*possible_number_array_element))) { croak("\nERROR ENVAVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_arrayref element value expected but undefined/null value found at index %ld,\ncroaking", i); }
  if (not(SvNOKp(*possible_number_array_element) || SvIOKp(*possible_number_array_element))) { croak("\nERROR ENVAVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_arrayref element value expected but non-number value found at index %ld,\ncroaking", i); }
 }
}

void number_arrayref_CHECKTRACE(SV* possible_number_arrayref, const char* variable_name, const char* subroutine_name)
{
    if ( not( SvOK(possible_number_arrayref) ) ) { croak( "\nERROR ENVAVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_arrayref value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }
    if ( not( (SvROK(possible_number_arrayref) && (SvTYPE(SvRV(possible_number_arrayref)) == SVt_PVAV)) ) ) { croak( "\nERROR ENVAVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_arrayref value expected but non-arrayref value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }

    AV* possible_number_array;
    integer possible_number_array_length;
    integer i;
    SV** possible_number_array_element;

    possible_number_array = (AV*)SvRV(possible_number_arrayref);
 possible_number_array_length = av_len(possible_number_array) + 1;

 for (i = 0; i < possible_number_array_length; ++i)
 {
  possible_number_array_element = av_fetch(possible_number_array, i, 0);

     if (not(SvOK(*possible_number_array_element))) { croak("\nERROR ENVAVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_arrayref element value expected but undefined/null value found at index %ld,\nin variable %s from subroutine %s,\ncroaking", i, variable_name, subroutine_name); }
  if (not(SvNOKp(*possible_number_array_element) || SvIOKp(*possible_number_array_element))) { croak("\nERROR ENVAVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_arrayref element value expected but non-number value found at index %ld,\nin variable %s from subroutine %s,\ncroaking", i, variable_name, subroutine_name); }
 }
}

void string_arrayref_CHECK(SV* possible_string_arrayref)
{
    if ( not( SvOK(possible_string_arrayref) ) ) { croak( "\nERROR EPVAVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_arrayref value expected but undefined/null value found,\ncroaking" ); }
    if ( not( (SvROK(possible_string_arrayref) && (SvTYPE(SvRV(possible_string_arrayref)) == SVt_PVAV)) ) ) { croak( "\nERROR EPVAVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_arrayref value expected but non-arrayref value found,\ncroaking" ); }

    AV* possible_string_array;
    integer possible_string_array_length;
    integer i;
    SV** possible_string_array_element;

    possible_string_array = (AV*)SvRV(possible_string_arrayref);
 possible_string_array_length = av_len(possible_string_array) + 1;

 for (i = 0; i < possible_string_array_length; ++i)
 {
  possible_string_array_element = av_fetch(possible_string_array, i, 0);

     if (not(SvOK(*possible_string_array_element))) { croak("\nERROR EPVAVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_arrayref element value expected but undefined/null value found at index %ld,\ncroaking", i); }
  if (not(SvPOKp(*possible_string_array_element))) { croak("\nERROR EPVAVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_arrayref element value expected but non-string value found at index %ld,\ncroaking", i); }
 }
}

void string_arrayref_CHECKTRACE(SV* possible_string_arrayref, const char* variable_name, const char* subroutine_name)
{
    if ( not( SvOK(possible_string_arrayref) ) ) { croak( "\nERROR EPVAVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_arrayref value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }
    if ( not( (SvROK(possible_string_arrayref) && (SvTYPE(SvRV(possible_string_arrayref)) == SVt_PVAV)) ) ) { croak( "\nERROR EPVAVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_arrayref value expected but non-arrayref value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }

    AV* possible_string_array;
    integer possible_string_array_length;
    integer i;
    SV** possible_string_array_element;

    possible_string_array = (AV*)SvRV(possible_string_arrayref);
 possible_string_array_length = av_len(possible_string_array) + 1;

 for (i = 0; i < possible_string_array_length; ++i)
 {
  possible_string_array_element = av_fetch(possible_string_array, i, 0);

     if (not(SvOK(*possible_string_array_element))) { croak("\nERROR EPVAVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_arrayref element value expected but undefined/null value found at index %ld,\nin variable %s from subroutine %s,\ncroaking", i, variable_name, subroutine_name); }
  if (not(SvPOKp(*possible_string_array_element))) { croak("\nERROR EPVAVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_arrayref element value expected but non-string value found at index %ld,\nin variable %s from subroutine %s,\ncroaking", i, variable_name, subroutine_name); }
 }
}
# 163 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.cpp"
integer_arrayref XS_unpack_integer_arrayref(SV* input_avref)
{


 integer_arrayref_CHECKTRACE(input_avref, "input_avref", "XS_unpack_integer_arrayref()");

    AV* input_av;
    integer input_av_length;
    integer i;
    SV** input_av_element;
    integer_arrayref output_vector;

    input_av = (AV*)SvRV(input_avref);
 input_av_length = av_len(input_av) + 1;






 output_vector.resize((size_t)input_av_length);
# 193 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.cpp"
 for (i = 0; i < input_av_length; ++i)

 {

  input_av_element = av_fetch(input_av, i, 0);





  output_vector[i] = SvIV(*input_av_element);
# 220 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.cpp"
 }




 return(output_vector);
}


void XS_pack_integer_arrayref(SV* output_avref, integer_arrayref input_vector)
{


 AV* output_av = newAV();
 integer input_vector_length = input_vector.size();
 integer i;
 SV* temp_sv_pointer;



 if (input_vector_length > 0) { for (i = 0; i < input_vector_length; ++i) { av_push(output_av, newSViv(input_vector[i])); } }


 temp_sv_pointer = newSVrv(output_avref, NULL);
 SvREFCNT_dec(temp_sv_pointer);
 SvRV(output_avref) = (SV*)output_av;


}


number_arrayref XS_unpack_number_arrayref(SV* input_avref)
{


 number_arrayref_CHECKTRACE(input_avref, "input_avref", "XS_unpack_number_arrayref()");

    AV* input_av;
    integer input_av_length;
    integer i;
    SV** input_av_element;
    number_arrayref output_vector;

    input_av = (AV*)SvRV(input_avref);
 input_av_length = av_len(input_av) + 1;




 output_vector.resize((size_t)input_av_length);

 for (i = 0; i < input_av_length; ++i)
 {

  input_av_element = av_fetch(input_av, i, 0);


  output_vector[i] = SvNV(*input_av_element);
 }




 return(output_vector);
}


void XS_pack_number_arrayref(SV* output_avref, number_arrayref input_vector)
{


 AV* output_av = newAV();
 integer input_vector_length = input_vector.size();
 integer i;
 SV* temp_sv_pointer;



 if (input_vector_length > 0) { for (i = 0; i < input_vector_length; ++i) { av_push(output_av, newSVnv(input_vector[i])); } }


 temp_sv_pointer = newSVrv(output_avref, NULL);
 SvREFCNT_dec(temp_sv_pointer);
 SvRV(output_avref) = (SV*)output_av;


}


string_arrayref XS_unpack_string_arrayref(SV* input_avref)
{


 string_arrayref_CHECKTRACE(input_avref, "input_avref", "XS_unpack_string_arrayref()");

    AV* input_av;
    integer input_av_length;
    integer i;
    SV** input_av_element;
    string_arrayref output_vector;

    input_av = (AV*)SvRV(input_avref);
 input_av_length = av_len(input_av) + 1;




 output_vector.resize((size_t)input_av_length);

 for (i = 0; i < input_av_length; ++i)
 {

  input_av_element = av_fetch(input_av, i, 0);


  output_vector[i] = SvPV_nolen(*input_av_element);
 }




 return(output_vector);
}


void XS_pack_string_arrayref(SV* output_avref, string_arrayref input_vector)
{


 AV* output_av = newAV();
 integer input_vector_length = input_vector.size();
 integer i;
 SV* temp_sv_pointer;



 if (input_vector_length > 0) { for (i = 0; i < input_vector_length; ++i) { av_push(output_av, newSVpv(input_vector[i].data(), input_vector[i].size())); } }


 temp_sv_pointer = newSVrv(output_avref, NULL);
 SvREFCNT_dec(temp_sv_pointer);
 SvRV(output_avref) = (SV*)output_av;


}
# 549 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.cpp"
string integer_arrayref_to_string(integer_arrayref input_vector)
{


 ostringstream output_stream;
 integer input_vector_length = input_vector.size();
 integer i;
 integer input_vector_element;
    boolean i_is_0 = 1;



 output_stream << '[';

 for (i = 0; i < input_vector_length; ++i)
 {

  input_vector_element = input_vector[i];
  if (i_is_0) { i_is_0 = 0; } else { output_stream << ", "; }
  output_stream << input_vector_element;
 }

 output_stream << ']';




 return(output_stream.str());
}


string number_arrayref_to_string(number_arrayref input_vector)
{


 ostringstream output_stream;
 integer input_vector_length = input_vector.size();
 integer i;
 number input_vector_element;
    boolean i_is_0 = 1;



 output_stream.precision(std::numeric_limits<double>::digits10);
 output_stream << '[';

 for (i = 0; i < input_vector_length; ++i)
 {

  input_vector_element = input_vector[i];
  if (i_is_0) { i_is_0 = 0; } else { output_stream << ", "; }

  output_stream << number_to_string(input_vector_element);
 }

 output_stream << ']';




 return(output_stream.str());
}


string string_arrayref_to_string(string_arrayref input_vector)
{



 string output_string;
 integer input_vector_length = input_vector.size();
 integer i;
 string input_vector_element;
    size_t input_vector_element_pos;
    boolean i_is_0 = 1;




 output_string = "[";

 for (i = 0; i < input_vector_length; ++i)
 {

  input_vector_element = input_vector[i];
  if (i_is_0) { i_is_0 = 0; } else { output_string += ", "; }


  input_vector_element_pos = 0;
  while((input_vector_element_pos = input_vector_element.find("\\", input_vector_element_pos)) != string::npos)
  {
   input_vector_element.replace(input_vector_element_pos, 1, "\\\\");
   input_vector_element_pos += 2;
  }
  input_vector_element_pos = 0;
  while((input_vector_element_pos = input_vector_element.find("'", input_vector_element_pos)) != string::npos)
  {
   input_vector_element.replace(input_vector_element_pos, 1, "\\'");
   input_vector_element_pos += 2;
  }


  output_string += "'" + input_vector_element + "'";
 }


 output_string += "]";






 return(output_string);
}
# 812 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Array.cpp"
string integer_arrayref__typetest0(integer_arrayref lucky_integers)
{
 integer how_lucky = lucky_integers.size();
 integer i;




 return(integer_arrayref_to_string(lucky_integers) + "CPPOPS_CPPTYPES");
}

integer_arrayref integer_arrayref__typetest1(integer my_size)
{
 integer_arrayref new_vec(my_size);
 integer i;
 for (i = 0; i < my_size; ++i) {
  new_vec[i] = i * 5;

 }
 return(new_vec);
}

string number_arrayref__typetest0(number_arrayref lucky_numbers)
{
 integer how_lucky = lucky_numbers.size();
 integer i;




 return(number_arrayref_to_string(lucky_numbers) + "CPPOPS_CPPTYPES");
}
number_arrayref number_arrayref__typetest1(integer my_size)
{
 number_arrayref new_vec(my_size);
 integer i;
 for (i = 0; i < my_size; ++i)
 {
  new_vec[i] = i * 5.123456789;

 }
 return(new_vec);
}


string string_arrayref__typetest0(string_arrayref people)
{
 integer i;




 return(string_arrayref_to_string(people) + "CPPOPS_CPPTYPES");
}

string_arrayref string_arrayref__typetest1(integer my_size)
{
 string_arrayref people;
 integer i;
 people.resize((size_t)my_size);
 for (i = 0; i < my_size; ++i)
 {
  people[i] = "Jeffy Ten! " + std::to_string(i) + "/" + std::to_string(my_size - 1) + " CPPOPS_CPPTYPES";

 }
 return(people);
}
# 14 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.cpp" 1
using std::cout; using std::cerr; using std::endl;




# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.h" 1

using std::cout; using std::cerr; using std::endl;
# 13 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.h"
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Integer.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 14 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/Number.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 15 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.h" 2
# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataType/String.cpp" 1
using std::cout; using std::cerr; using std::endl;
# 16 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.h" 2
# 40 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.h"
typedef std::unordered_map<string, integer> integer_hashref;
typedef std::unordered_map<string, integer>::iterator integer_hashref_iterator;
typedef std::unordered_map<string, integer>::const_iterator integer_hashref_const_iterator;
typedef std::unordered_map<string, number> number_hashref;
typedef std::unordered_map<string, number>::iterator number_hashref_iterator;
typedef std::unordered_map<string, number>::const_iterator number_hashref_const_iterator;
typedef std::unordered_map<string, string> string_hashref;
typedef std::unordered_map<string, string>::iterator string_hashref_iterator;
typedef std::unordered_map<string, string>::const_iterator string_hashref_const_iterator;


void integer_hashref_CHECK(SV* possible_integer_hashref);
void integer_hashref_CHECKTRACE(SV* possible_integer_hashref, const char* variable_name, const char* subroutine_name);
void number_hashref_CHECK(SV* possible_number_hashref);
void number_hashref_CHECKTRACE(SV* possible_number_hashref, const char* variable_name, const char* subroutine_name);
void string_hashref_CHECK(SV* possible_string_hashref);
void string_hashref_CHECKTRACE(SV* possible_string_hashref, const char* variable_name, const char* subroutine_name);





integer RPerl__DataStructure__Hash__MODE_ID() { return 2; }






integer_hashref XS_unpack_integer_hashref(SV* input_hv_ref);
void XS_pack_integer_hashref(SV* output_hv_ref, integer_hashref input_unordered_map);
number_hashref XS_unpack_number_hashref(SV* input_hv_ref);
void XS_pack_number_hashref(SV* output_hv_ref, number_hashref input_unordered_map);
string_hashref XS_unpack_string_hashref(SV* input_hv_ref);
void XS_pack_string_hashref(SV* output_hv_ref, string_hashref input_unordered_map);
# 83 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.h"
string integer_hashref_to_string(integer_hashref input_unordered_map);
string number_hashref_to_string(number_hashref input_unordered_map);
string string_hashref_to_string(string_hashref input_unordered_map);
# 97 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.h"
string integer_hashref__typetest0(integer_hashref lucky_integers);
integer_hashref integer_hashref__typetest1(integer my_size);
string number_hashref__typetest0(number_hashref lucky_numbers);
number_hashref number_hashref__typetest1(integer my_size);
string string_hashref__typetest0(string_hashref people);
string_hashref string_hashref__typetest1(integer my_size);
# 7 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.cpp" 2






void integer_hashref_CHECK(SV* possible_integer_hashref)
{

    if ( not( SvOK(possible_integer_hashref) ) ) { croak( "\nERROR EIVHVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashref value expected but undefined/null value found,\ncroaking" ); }
    if ( not( (SvROK(possible_integer_hashref) && (SvTYPE(SvRV(possible_integer_hashref)) == SVt_PVHV)) ) ) { croak( "\nERROR EIVHVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashref value expected but non-hashref value found,\ncroaking" ); }

    HV* possible_integer_hash;
    integer possible_integer_hash_num_keys;
    integer i;
    HE* possible_integer_hashentry;
    SV* possible_integer_hashentry_value;
    SV* possible_integer_hashentry_key;
    string possible_integer_hashentry_key_string;
    size_t possible_integer_hashentry_key_string_pos;

 possible_integer_hash = (HV*)SvRV(possible_integer_hashref);
 possible_integer_hash_num_keys = hv_iterinit(possible_integer_hash);

 for (i = 0; i < possible_integer_hash_num_keys; ++i)
 {
  possible_integer_hashentry = hv_iternext(possible_integer_hash);


  if (possible_integer_hashentry == NULL) { croak("\nERROR EIVHE00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashentry value expected but undefined/null value found,\ncroaking"); }
  possible_integer_hashentry_value = hv_iterval(possible_integer_hash, possible_integer_hashentry);


     if (not(SvOK(possible_integer_hashentry_value)))
     {
      possible_integer_hashentry_key = hv_iterkeysv(possible_integer_hashentry);


   possible_integer_hashentry_key_string = string(SvPV_nolen(possible_integer_hashentry_key));
   possible_integer_hashentry_key_string_pos = 0;
   while((possible_integer_hashentry_key_string_pos = possible_integer_hashentry_key_string.find("\\", possible_integer_hashentry_key_string_pos)) != string::npos)
   {
    possible_integer_hashentry_key_string.replace(possible_integer_hashentry_key_string_pos, 1, "\\\\");
    possible_integer_hashentry_key_string_pos += 2;
   }
   possible_integer_hashentry_key_string_pos = 0;
   while((possible_integer_hashentry_key_string_pos = possible_integer_hashentry_key_string.find("'", possible_integer_hashentry_key_string_pos)) != string::npos)
   {
    possible_integer_hashentry_key_string.replace(possible_integer_hashentry_key_string_pos, 1, "\\'");
    possible_integer_hashentry_key_string_pos += 2;
   }

      croak("\nERROR EIVHVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashref element value expected but undefined/null value found at key '%s',\ncroaking", possible_integer_hashentry_key_string.c_str());
     }
  if (not(SvIOKp(possible_integer_hashentry_value)))
  {
      possible_integer_hashentry_key = hv_iterkeysv(possible_integer_hashentry);


   possible_integer_hashentry_key_string = string(SvPV_nolen(possible_integer_hashentry_key));
   possible_integer_hashentry_key_string_pos = 0;
   while((possible_integer_hashentry_key_string_pos = possible_integer_hashentry_key_string.find("\\", possible_integer_hashentry_key_string_pos)) != string::npos)
   {
    possible_integer_hashentry_key_string.replace(possible_integer_hashentry_key_string_pos, 1, "\\\\");
    possible_integer_hashentry_key_string_pos += 2;
   }
   possible_integer_hashentry_key_string_pos = 0;
   while((possible_integer_hashentry_key_string_pos = possible_integer_hashentry_key_string.find("'", possible_integer_hashentry_key_string_pos)) != string::npos)
   {
    possible_integer_hashentry_key_string.replace(possible_integer_hashentry_key_string_pos, 1, "\\'");
    possible_integer_hashentry_key_string_pos += 2;
   }

   croak("\nERROR EIVHVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashref element value expected but non-integer value found at key '%s',\ncroaking", possible_integer_hashentry_key_string.c_str());
  }
 }
}

void integer_hashref_CHECKTRACE(SV* possible_integer_hashref, const char* variable_name, const char* subroutine_name)
{
    if ( not( SvOK(possible_integer_hashref) ) ) { croak( "\nERROR EIVHVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashref value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }
    if ( not( (SvROK(possible_integer_hashref) && (SvTYPE(SvRV(possible_integer_hashref)) == SVt_PVHV)) ) ) { croak( "\nERROR EIVHVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashref value expected but non-hashref value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }

    HV* possible_integer_hash;
    integer possible_integer_hash_num_keys;
    integer i;
    HE* possible_integer_hashentry;
    SV* possible_integer_hashentry_value;
    SV* possible_integer_hashentry_key;
    string possible_integer_hashentry_key_string;
    size_t possible_integer_hashentry_key_string_pos;

 possible_integer_hash = (HV*)SvRV(possible_integer_hashref);
 possible_integer_hash_num_keys = hv_iterinit(possible_integer_hash);

 for (i = 0; i < possible_integer_hash_num_keys; ++i)
 {
  possible_integer_hashentry = hv_iternext(possible_integer_hash);

  if (possible_integer_hashentry == NULL) { croak("\nERROR EIVHE00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashentry value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name); }
  possible_integer_hashentry_value = hv_iterval(possible_integer_hash, possible_integer_hashentry);

     if (not(SvOK(possible_integer_hashentry_value)))
     {
      possible_integer_hashentry_key = hv_iterkeysv(possible_integer_hashentry);


   possible_integer_hashentry_key_string = string(SvPV_nolen(possible_integer_hashentry_key));
   possible_integer_hashentry_key_string_pos = 0;
   while((possible_integer_hashentry_key_string_pos = possible_integer_hashentry_key_string.find("\\", possible_integer_hashentry_key_string_pos)) != string::npos)
   {
    possible_integer_hashentry_key_string.replace(possible_integer_hashentry_key_string_pos, 1, "\\\\");
    possible_integer_hashentry_key_string_pos += 2;
   }
   possible_integer_hashentry_key_string_pos = 0;
   while((possible_integer_hashentry_key_string_pos = possible_integer_hashentry_key_string.find("'", possible_integer_hashentry_key_string_pos)) != string::npos)
   {
    possible_integer_hashentry_key_string.replace(possible_integer_hashentry_key_string_pos, 1, "\\'");
    possible_integer_hashentry_key_string_pos += 2;
   }

      croak("\nERROR EIVHVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashref element value expected but undefined/null value found at key '%s',\nin variable %s from subroutine %s,\ncroaking", possible_integer_hashentry_key_string.c_str(), variable_name, subroutine_name);
     }
  if (not(SvIOKp(possible_integer_hashentry_value)))
  {
      possible_integer_hashentry_key = hv_iterkeysv(possible_integer_hashentry);


   possible_integer_hashentry_key_string = string(SvPV_nolen(possible_integer_hashentry_key));
   possible_integer_hashentry_key_string_pos = 0;
   while((possible_integer_hashentry_key_string_pos = possible_integer_hashentry_key_string.find("\\", possible_integer_hashentry_key_string_pos)) != string::npos)
   {
    possible_integer_hashentry_key_string.replace(possible_integer_hashentry_key_string_pos, 1, "\\\\");
    possible_integer_hashentry_key_string_pos += 2;
   }
   possible_integer_hashentry_key_string_pos = 0;
   while((possible_integer_hashentry_key_string_pos = possible_integer_hashentry_key_string.find("'", possible_integer_hashentry_key_string_pos)) != string::npos)
   {
    possible_integer_hashentry_key_string.replace(possible_integer_hashentry_key_string_pos, 1, "\\'");
    possible_integer_hashentry_key_string_pos += 2;
   }

   croak("\nERROR EIVHVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\ninteger_hashref element value expected but non-integer value found at key '%s',\nin variable %s from subroutine %s,\ncroaking", possible_integer_hashentry_key_string.c_str(), variable_name, subroutine_name);
  }
 }
}

void number_hashref_CHECK(SV* possible_number_hashref)
{
    if ( not( SvOK(possible_number_hashref) ) ) { croak( "\nERROR ENVHVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashref value expected but undefined/null value found,\ncroaking" ); }
    if ( not( (SvROK(possible_number_hashref) && (SvTYPE(SvRV(possible_number_hashref)) == SVt_PVHV)) ) ) { croak( "\nERROR ENVHVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashref value expected but non-hashref value found,\ncroaking" ); }

    HV* possible_number_hash;
    integer possible_number_hash_num_keys;
    integer i;
    HE* possible_number_hashentry;
    SV* possible_number_hashentry_value;
    SV* possible_number_hashentry_key;
    string possible_number_hashentry_key_string;
    size_t possible_number_hashentry_key_string_pos;

 possible_number_hash = (HV*)SvRV(possible_number_hashref);
 possible_number_hash_num_keys = hv_iterinit(possible_number_hash);

 for (i = 0; i < possible_number_hash_num_keys; ++i)
 {
  possible_number_hashentry = hv_iternext(possible_number_hash);

  if (possible_number_hashentry == NULL) { croak("\nERROR ENVHE00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashentry value expected but undefined/null value found,\ncroaking"); }
  possible_number_hashentry_value = hv_iterval(possible_number_hash, possible_number_hashentry);

     if (not(SvOK(possible_number_hashentry_value)))
     {
      possible_number_hashentry_key = hv_iterkeysv(possible_number_hashentry);


   possible_number_hashentry_key_string = string(SvPV_nolen(possible_number_hashentry_key));
   possible_number_hashentry_key_string_pos = 0;
   while((possible_number_hashentry_key_string_pos = possible_number_hashentry_key_string.find("\\", possible_number_hashentry_key_string_pos)) != string::npos)
   {
    possible_number_hashentry_key_string.replace(possible_number_hashentry_key_string_pos, 1, "\\\\");
    possible_number_hashentry_key_string_pos += 2;
   }
   possible_number_hashentry_key_string_pos = 0;
   while((possible_number_hashentry_key_string_pos = possible_number_hashentry_key_string.find("'", possible_number_hashentry_key_string_pos)) != string::npos)
   {
    possible_number_hashentry_key_string.replace(possible_number_hashentry_key_string_pos, 1, "\\'");
    possible_number_hashentry_key_string_pos += 2;
   }

      croak("\nERROR ENVHVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashref element value expected but undefined/null value found at key '%s',\ncroaking", possible_number_hashentry_key_string.c_str());
     }
  if (not(SvNOKp(possible_number_hashentry_value) || SvIOKp(possible_number_hashentry_value)))
  {
      possible_number_hashentry_key = hv_iterkeysv(possible_number_hashentry);


   possible_number_hashentry_key_string = string(SvPV_nolen(possible_number_hashentry_key));
   possible_number_hashentry_key_string_pos = 0;
   while((possible_number_hashentry_key_string_pos = possible_number_hashentry_key_string.find("\\", possible_number_hashentry_key_string_pos)) != string::npos)
   {
    possible_number_hashentry_key_string.replace(possible_number_hashentry_key_string_pos, 1, "\\\\");
    possible_number_hashentry_key_string_pos += 2;
   }
   possible_number_hashentry_key_string_pos = 0;
   while((possible_number_hashentry_key_string_pos = possible_number_hashentry_key_string.find("'", possible_number_hashentry_key_string_pos)) != string::npos)
   {
    possible_number_hashentry_key_string.replace(possible_number_hashentry_key_string_pos, 1, "\\'");
    possible_number_hashentry_key_string_pos += 2;
   }

   croak("\nERROR ENVHVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashref element value expected but non-number value found at key '%s',\ncroaking", possible_number_hashentry_key_string.c_str());
  }
 }
}

void number_hashref_CHECKTRACE(SV* possible_number_hashref, const char* variable_name, const char* subroutine_name)
{
    if ( not( SvOK(possible_number_hashref) ) ) { croak( "\nERROR ENVHVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashref value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }
    if ( not( (SvROK(possible_number_hashref) && (SvTYPE(SvRV(possible_number_hashref)) == SVt_PVHV)) ) ) { croak( "\nERROR ENVHVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashref value expected but non-hashref value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }

    HV* possible_number_hash;
    integer possible_number_hash_num_keys;
    integer i;
    HE* possible_number_hashentry;
    SV* possible_number_hashentry_value;
    SV* possible_number_hashentry_key;
    string possible_number_hashentry_key_string;
    size_t possible_number_hashentry_key_string_pos;

 possible_number_hash = (HV*)SvRV(possible_number_hashref);
 possible_number_hash_num_keys = hv_iterinit(possible_number_hash);

 for (i = 0; i < possible_number_hash_num_keys; ++i)
 {
  possible_number_hashentry = hv_iternext(possible_number_hash);

  if (possible_number_hashentry == NULL) { croak("\nERROR ENVHE00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashentry value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name); }
  possible_number_hashentry_value = hv_iterval(possible_number_hash, possible_number_hashentry);

     if (not(SvOK(possible_number_hashentry_value)))
     {
      possible_number_hashentry_key = hv_iterkeysv(possible_number_hashentry);


   possible_number_hashentry_key_string = string(SvPV_nolen(possible_number_hashentry_key));
   possible_number_hashentry_key_string_pos = 0;
   while((possible_number_hashentry_key_string_pos = possible_number_hashentry_key_string.find("\\", possible_number_hashentry_key_string_pos)) != string::npos)
   {
    possible_number_hashentry_key_string.replace(possible_number_hashentry_key_string_pos, 1, "\\\\");
    possible_number_hashentry_key_string_pos += 2;
   }
   possible_number_hashentry_key_string_pos = 0;
   while((possible_number_hashentry_key_string_pos = possible_number_hashentry_key_string.find("'", possible_number_hashentry_key_string_pos)) != string::npos)
   {
    possible_number_hashentry_key_string.replace(possible_number_hashentry_key_string_pos, 1, "\\'");
    possible_number_hashentry_key_string_pos += 2;
   }

      croak("\nERROR ENVHVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashref element value expected but undefined/null value found at key '%s',\nin variable %s from subroutine %s,\ncroaking", possible_number_hashentry_key_string.c_str(), variable_name, subroutine_name);
     }
  if (not(SvNOKp(possible_number_hashentry_value) || SvIOKp(possible_number_hashentry_value)))
  {
      possible_number_hashentry_key = hv_iterkeysv(possible_number_hashentry);


   possible_number_hashentry_key_string = string(SvPV_nolen(possible_number_hashentry_key));
   possible_number_hashentry_key_string_pos = 0;
   while((possible_number_hashentry_key_string_pos = possible_number_hashentry_key_string.find("\\", possible_number_hashentry_key_string_pos)) != string::npos)
   {
    possible_number_hashentry_key_string.replace(possible_number_hashentry_key_string_pos, 1, "\\\\");
    possible_number_hashentry_key_string_pos += 2;
   }
   possible_number_hashentry_key_string_pos = 0;
   while((possible_number_hashentry_key_string_pos = possible_number_hashentry_key_string.find("'", possible_number_hashentry_key_string_pos)) != string::npos)
   {
    possible_number_hashentry_key_string.replace(possible_number_hashentry_key_string_pos, 1, "\\'");
    possible_number_hashentry_key_string_pos += 2;
   }

   croak("\nERROR ENVHVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nnumber_hashref element value expected but non-number value found at key '%s',\nin variable %s from subroutine %s,\ncroaking", possible_number_hashentry_key_string.c_str(), variable_name, subroutine_name);
  }
 }
}

void string_hashref_CHECK(SV* possible_string_hashref)
{
    if ( not( SvOK(possible_string_hashref) ) ) { croak( "\nERROR EPVHVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashref value expected but undefined/null value found,\ncroaking" ); }
    if ( not( (SvROK(possible_string_hashref) && (SvTYPE(SvRV(possible_string_hashref)) == SVt_PVHV)) ) ) { croak( "\nERROR EPVHVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashref value expected but non-hashref value found,\ncroaking" ); }

    HV* possible_string_hash;
    integer possible_string_hash_num_keys;
    integer i;
    HE* possible_string_hashentry;
    SV* possible_string_hashentry_value;
    SV* possible_string_hashentry_key;
    string possible_string_hashentry_key_string;
    size_t possible_string_hashentry_key_string_pos;

 possible_string_hash = (HV*)SvRV(possible_string_hashref);
 possible_string_hash_num_keys = hv_iterinit(possible_string_hash);

 for (i = 0; i < possible_string_hash_num_keys; ++i)
 {
  possible_string_hashentry = hv_iternext(possible_string_hash);

  if (possible_string_hashentry == NULL) { croak("\nERROR EPVHE00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashentry value expected but undefined/null value found,\ncroaking"); }
  possible_string_hashentry_value = hv_iterval(possible_string_hash, possible_string_hashentry);

     if (not(SvOK(possible_string_hashentry_value)))
     {
      possible_string_hashentry_key = hv_iterkeysv(possible_string_hashentry);


   possible_string_hashentry_key_string = string(SvPV_nolen(possible_string_hashentry_key));
   possible_string_hashentry_key_string_pos = 0;
   while((possible_string_hashentry_key_string_pos = possible_string_hashentry_key_string.find("\\", possible_string_hashentry_key_string_pos)) != string::npos)
   {
    possible_string_hashentry_key_string.replace(possible_string_hashentry_key_string_pos, 1, "\\\\");
    possible_string_hashentry_key_string_pos += 2;
   }
   possible_string_hashentry_key_string_pos = 0;
   while((possible_string_hashentry_key_string_pos = possible_string_hashentry_key_string.find("'", possible_string_hashentry_key_string_pos)) != string::npos)
   {
    possible_string_hashentry_key_string.replace(possible_string_hashentry_key_string_pos, 1, "\\'");
    possible_string_hashentry_key_string_pos += 2;
   }

      croak("\nERROR EPVHVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashref element value expected but undefined/null value found at key '%s',\ncroaking", possible_string_hashentry_key_string.c_str());
     }
  if (not(SvPOKp(possible_string_hashentry_value)))
  {
      possible_string_hashentry_key = hv_iterkeysv(possible_string_hashentry);


   possible_string_hashentry_key_string = string(SvPV_nolen(possible_string_hashentry_key));
   possible_string_hashentry_key_string_pos = 0;
   while((possible_string_hashentry_key_string_pos = possible_string_hashentry_key_string.find("\\", possible_string_hashentry_key_string_pos)) != string::npos)
   {
    possible_string_hashentry_key_string.replace(possible_string_hashentry_key_string_pos, 1, "\\\\");
    possible_string_hashentry_key_string_pos += 2;
   }
   possible_string_hashentry_key_string_pos = 0;
   while((possible_string_hashentry_key_string_pos = possible_string_hashentry_key_string.find("'", possible_string_hashentry_key_string_pos)) != string::npos)
   {
    possible_string_hashentry_key_string.replace(possible_string_hashentry_key_string_pos, 1, "\\'");
    possible_string_hashentry_key_string_pos += 2;
   }

   croak("\nERROR EPVHVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashref element value expected but non-string value found at key '%s',\ncroaking", possible_string_hashentry_key_string.c_str());
  }
 }
}

void string_hashref_CHECKTRACE(SV* possible_string_hashref, const char* variable_name, const char* subroutine_name)
{
    if ( not( SvOK(possible_string_hashref) ) ) { croak( "\nERROR EPVHVRV00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashref value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }
    if ( not( (SvROK(possible_string_hashref) && (SvTYPE(SvRV(possible_string_hashref)) == SVt_PVHV)) ) ) { croak( "\nERROR EPVHVRV01, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashref value expected but non-hashref value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name ); }

    HV* possible_string_hash;
    integer possible_string_hash_num_keys;
    integer i;
    HE* possible_string_hashentry;
    SV* possible_string_hashentry_value;
    SV* possible_string_hashentry_key;
    string possible_string_hashentry_key_string;
    size_t possible_string_hashentry_key_string_pos;

 possible_string_hash = (HV*)SvRV(possible_string_hashref);
 possible_string_hash_num_keys = hv_iterinit(possible_string_hash);

 for (i = 0; i < possible_string_hash_num_keys; ++i)
 {
  possible_string_hashentry = hv_iternext(possible_string_hash);

  if (possible_string_hashentry == NULL) { croak("\nERROR EPVHE00, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashentry value expected but undefined/null value found,\nin variable %s from subroutine %s,\ncroaking", variable_name, subroutine_name); }
  possible_string_hashentry_value = hv_iterval(possible_string_hash, possible_string_hashentry);

     if (not(SvOK(possible_string_hashentry_value)))
     {
      possible_string_hashentry_key = hv_iterkeysv(possible_string_hashentry);


   possible_string_hashentry_key_string = string(SvPV_nolen(possible_string_hashentry_key));
   possible_string_hashentry_key_string_pos = 0;
   while((possible_string_hashentry_key_string_pos = possible_string_hashentry_key_string.find("\\", possible_string_hashentry_key_string_pos)) != string::npos)
   {
    possible_string_hashentry_key_string.replace(possible_string_hashentry_key_string_pos, 1, "\\\\");
    possible_string_hashentry_key_string_pos += 2;
   }
   possible_string_hashentry_key_string_pos = 0;
   while((possible_string_hashentry_key_string_pos = possible_string_hashentry_key_string.find("'", possible_string_hashentry_key_string_pos)) != string::npos)
   {
    possible_string_hashentry_key_string.replace(possible_string_hashentry_key_string_pos, 1, "\\'");
    possible_string_hashentry_key_string_pos += 2;
   }

      croak("\nERROR EPVHVRV02, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashref element value expected but undefined/null value found at key '%s',\nin variable %s from subroutine %s,\ncroaking", possible_string_hashentry_key_string.c_str(), variable_name, subroutine_name);
     }
  if (not(SvPOKp(possible_string_hashentry_value)))
  {
      possible_string_hashentry_key = hv_iterkeysv(possible_string_hashentry);


   possible_string_hashentry_key_string = string(SvPV_nolen(possible_string_hashentry_key));
   possible_string_hashentry_key_string_pos = 0;
   while((possible_string_hashentry_key_string_pos = possible_string_hashentry_key_string.find("\\", possible_string_hashentry_key_string_pos)) != string::npos)
   {
    possible_string_hashentry_key_string.replace(possible_string_hashentry_key_string_pos, 1, "\\\\");
    possible_string_hashentry_key_string_pos += 2;
   }
   possible_string_hashentry_key_string_pos = 0;
   while((possible_string_hashentry_key_string_pos = possible_string_hashentry_key_string.find("'", possible_string_hashentry_key_string_pos)) != string::npos)
   {
    possible_string_hashentry_key_string.replace(possible_string_hashentry_key_string_pos, 1, "\\'");
    possible_string_hashentry_key_string_pos += 2;
   }

   croak("\nERROR EPVHVRV03, TYPE-CHECKING MISMATCH, CPPOPS_PERLTYPES & CPPOPS_CPPTYPES:\nstring_hashref element value expected but non-string value found at key '%s',\nin variable %s from subroutine %s,\ncroaking", possible_string_hashentry_key_string.c_str(), variable_name, subroutine_name);
  }
 }
}
# 437 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.cpp"
integer_hashref XS_unpack_integer_hashref(SV* input_hv_ref)
{


 integer_hashref_CHECKTRACE(input_hv_ref, "input_hv_ref", "XS_unpack_integer_hashref()");

    HV* input_hv;
    integer input_hv_num_keys;
    integer i;
    HE* input_hv_entry;
    SV* input_hv_entry_key;
    SV* input_hv_entry_value;
    integer_hashref output_unordered_map;

 input_hv = (HV*)SvRV(input_hv_ref);

 input_hv_num_keys = hv_iterinit(input_hv);




 output_unordered_map.reserve((size_t)input_hv_num_keys);

 for (i = 0; i < input_hv_num_keys; ++i)
 {

  input_hv_entry = hv_iternext(input_hv);




  input_hv_entry_key = hv_iterkeysv(input_hv_entry);
  input_hv_entry_value = hv_iterval(input_hv, input_hv_entry);





  output_unordered_map[SvPV_nolen(input_hv_entry_key)] = SvIV(input_hv_entry_value);
 }




 return(output_unordered_map);
}


void XS_pack_integer_hashref(SV* output_hv_ref, integer_hashref input_unordered_map)
{


 HV* output_hv = newHV();
 integer input_unordered_map_num_keys = input_unordered_map.size();
 integer_hashref_const_iterator i;
 SV* temp_sv_pointer;



 if (input_unordered_map_num_keys > 0)
 {
  for (i = input_unordered_map.begin(); i != input_unordered_map.end(); ++i)
   { hv_store(output_hv, (const char*)((i->first).c_str()), (U32)((i->first).size()), newSViv(i->second), (U32)0); }
 }


 temp_sv_pointer = newSVrv(output_hv_ref, NULL);
 SvREFCNT_dec(temp_sv_pointer);
 SvRV(output_hv_ref) = (SV*)output_hv;


}


number_hashref XS_unpack_number_hashref(SV* input_hv_ref)
{


 number_hashref_CHECKTRACE(input_hv_ref, "input_hv_ref", "XS_unpack_number_hashref()");

    HV* input_hv;
    integer input_hv_num_keys;
    integer i;
    HE* input_hv_entry;
    SV* input_hv_entry_key;
    SV* input_hv_entry_value;
    number_hashref output_unordered_map;

 input_hv = (HV*)SvRV(input_hv_ref);

 input_hv_num_keys = hv_iterinit(input_hv);




 output_unordered_map.reserve((size_t)input_hv_num_keys);

 for (i = 0; i < input_hv_num_keys; ++i)
 {

  input_hv_entry = hv_iternext(input_hv);
  input_hv_entry_key = hv_iterkeysv(input_hv_entry);
  input_hv_entry_value = hv_iterval(input_hv, input_hv_entry);


  output_unordered_map[SvPV_nolen(input_hv_entry_key)] = SvNV(input_hv_entry_value);
 }




 return(output_unordered_map);
}


void XS_pack_number_hashref(SV* output_hv_ref, number_hashref input_unordered_map)
{


 HV* output_hv = newHV();
 integer input_unordered_map_num_keys = input_unordered_map.size();
 number_hashref_const_iterator i;
 SV* temp_sv_pointer;



 if (input_unordered_map_num_keys > 0)
 {
  for (i = input_unordered_map.begin(); i != input_unordered_map.end(); ++i)
   { hv_store(output_hv, (const char*)((i->first).c_str()), (U32)((i->first).size()), newSVnv(i->second), (U32)0); }
 }


 temp_sv_pointer = newSVrv(output_hv_ref, NULL);
 SvREFCNT_dec(temp_sv_pointer);
 SvRV(output_hv_ref) = (SV*)output_hv;


}


string_hashref XS_unpack_string_hashref(SV* input_hv_ref)
{


 string_hashref_CHECKTRACE(input_hv_ref, "input_hv_ref", "XS_unpack_string_hashref()");

    HV* input_hv;
    integer input_hv_num_keys;
    integer i;
    HE* input_hv_entry;
    SV* input_hv_entry_key;
    SV* input_hv_entry_value;
    string_hashref output_unordered_map;

 input_hv = (HV*)SvRV(input_hv_ref);

 input_hv_num_keys = hv_iterinit(input_hv);




 output_unordered_map.reserve((size_t)input_hv_num_keys);

 for (i = 0; i < input_hv_num_keys; ++i)
 {

  input_hv_entry = hv_iternext(input_hv);
  input_hv_entry_key = hv_iterkeysv(input_hv_entry);
  input_hv_entry_value = hv_iterval(input_hv, input_hv_entry);


  output_unordered_map[SvPV_nolen(input_hv_entry_key)] = SvPV_nolen(input_hv_entry_value);
 }




 return(output_unordered_map);
}


void XS_pack_string_hashref(SV* output_hv_ref, string_hashref input_unordered_map)
{


 HV* output_hv = newHV();
 integer input_unordered_map_num_keys = input_unordered_map.size();
 string_hashref_const_iterator i;
 SV* temp_sv_pointer;



 if (input_unordered_map_num_keys > 0)
 {
  for (i = input_unordered_map.begin(); i != input_unordered_map.end(); ++i)
   { hv_store(output_hv, (const char*)((i->first).c_str()), (U32)((i->first).size()), newSVpv((i->second).c_str(), 0), (U32)0); }
 }


 temp_sv_pointer = newSVrv(output_hv_ref, NULL);
 SvREFCNT_dec(temp_sv_pointer);
 SvRV(output_hv_ref) = (SV*)output_hv;


}
# 864 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.cpp"
string integer_hashref_to_string(integer_hashref input_unordered_map)
{


 ostringstream output_stream;
 integer_hashref_const_iterator i;
    boolean i_is_0 = 1;
    string key_string;
    size_t key_string_pos;

 output_stream << '{';

 for (i = input_unordered_map.begin(); i != input_unordered_map.end(); ++i)
 {
  if (i_is_0) { i_is_0 = 0; } else { output_stream << ", "; }


  key_string = i->first;
  key_string_pos = 0;
  while((key_string_pos = key_string.find("\\", key_string_pos)) != string::npos)
  {
   key_string.replace(key_string_pos, 1, "\\\\");
   key_string_pos += 2;
  }
  key_string_pos = 0;
  while((key_string_pos = key_string.find("'", key_string_pos)) != string::npos)
  {
   key_string.replace(key_string_pos, 1, "\\'");
   key_string_pos += 2;
  }


  output_stream << "'" << key_string.c_str() << "' => " << i->second;
 }

 output_stream << '}';




 return(output_stream.str());
}


string number_hashref_to_string(number_hashref input_unordered_map)
{


 ostringstream output_stream;
 number_hashref_const_iterator i;
    boolean i_is_0 = 1;
    string key_string;
    size_t key_string_pos;

 output_stream.precision(std::numeric_limits<double>::digits10);
 output_stream << '{';

 for (i = input_unordered_map.begin(); i != input_unordered_map.end(); ++i)
 {
  if (i_is_0) { i_is_0 = 0; } else { output_stream << ", "; }


  key_string = i->first;
  key_string_pos = 0;
  while((key_string_pos = key_string.find("\\", key_string_pos)) != string::npos)
  {
   key_string.replace(key_string_pos, 1, "\\\\");
   key_string_pos += 2;
  }
  key_string_pos = 0;
  while((key_string_pos = key_string.find("'", key_string_pos)) != string::npos)
  {
   key_string.replace(key_string_pos, 1, "\\'");
   key_string_pos += 2;
  }


  output_stream << "'" << key_string.c_str() << "' => " << number_to_string(i->second);
 }

 output_stream << '}';




 return(output_stream.str());
}


string string_hashref_to_string(string_hashref input_unordered_map)
{


 string output_string;
 string_hashref_const_iterator i;
    boolean i_is_0 = 1;
    string key_string;
    size_t key_string_pos;
    string value_string;
    size_t value_string_pos;

 output_string = "{";

 for (i = input_unordered_map.begin(); i != input_unordered_map.end(); ++i)
 {
  if (i_is_0) { i_is_0 = 0; } else { output_string += ", "; }


  key_string = i->first;
  key_string_pos = 0;
  while((key_string_pos = key_string.find("\\", key_string_pos)) != string::npos)
  {
   key_string.replace(key_string_pos, 1, "\\\\");
   key_string_pos += 2;
  }
  key_string_pos = 0;
  while((key_string_pos = key_string.find("'", key_string_pos)) != string::npos)
  {
   key_string.replace(key_string_pos, 1, "\\'");
   key_string_pos += 2;
  }


  value_string = i->second;
  value_string_pos = 0;
  while((value_string_pos = value_string.find("\\", value_string_pos)) != string::npos)
  {
   value_string.replace(value_string_pos, 1, "\\\\");
   value_string_pos += 2;
  }
  value_string_pos = 0;
  while((value_string_pos = value_string.find("'", value_string_pos)) != string::npos)
  {
   value_string.replace(value_string_pos, 1, "\\'");
   value_string_pos += 2;
  }


  output_string += "'" + key_string + "' => '" + value_string + "'";
 }

 output_string += "}";




 return(output_string);
}
# 1145 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/DataStructure/Hash.cpp"
string integer_hashref__typetest0(integer_hashref lucky_integers)
{







 return(integer_hashref_to_string(lucky_integers) + "CPPOPS_CPPTYPES");
}

integer_hashref integer_hashref__typetest1(integer my_size)
{
 integer_hashref new_unordered_map(my_size);
 integer i;
 string temp_key;
 for (i = 0; i < my_size; ++i)
 {
  temp_key = "CPPOPS_CPPTYPES_funkey" + std::to_string(i);
  new_unordered_map[temp_key] = i * 5;

 }
 return(new_unordered_map);
}

string number_hashref__typetest0(number_hashref lucky_numbers)
{







 return(number_hashref_to_string(lucky_numbers) + "CPPOPS_CPPTYPES");
}

number_hashref number_hashref__typetest1(integer my_size)
{
 number_hashref new_unordered_map(my_size);
 integer i;
 string temp_key;
 for (i = 0; i < my_size; ++i)
 {
  temp_key = "CPPOPS_CPPTYPES_funkey" + std::to_string(i);
  new_unordered_map[temp_key] = i * 5.123456789;

 }
 return(new_unordered_map);
}

string string_hashref__typetest0(string_hashref people)
{







 return(string_hashref_to_string(people) + "CPPOPS_CPPTYPES");
}

string_hashref string_hashref__typetest1(integer my_size)
{
 string_hashref people;
 integer i;
 people.reserve((size_t)my_size);
 for (i = 0; i < my_size; ++i)
 {
  people["CPPOPS_CPPTYPES_Luker_key" + std::to_string(i)] = "Jeffy Ten! " + std::to_string(i) + "/" + std::to_string(my_size - 1);

 }
 return(people);
}
# 15 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h" 2
# 27 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/rperltypes.h"
number to_number(boolean input_boolean) { return boolean_to_number(input_boolean); }
number to_number(unsigned_integer input_unsigned_integer) { return unsigned_integer_to_number(input_unsigned_integer); }
number to_number(integer input_integer) { return integer_to_number(input_integer); }


number to_number(character input_character) { return character_to_number(input_character); }
number to_number(string input_string) { return string_to_number(input_string); }




string To_string(boolean input_boolean) { return boolean_to_string(input_boolean); }
string To_string(unsigned_integer input_unsigned_integer) { return unsigned_integer_to_string(input_unsigned_integer); }
string To_string(integer input_integer) { return integer_to_string(input_integer); }

string To_string(number input_number) { return number_to_string(input_number); }
string To_string(character input_character) { return character_to_string(input_character); }
string To_string(string input_string) { return string_to_string(input_string); }
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl.h" 2
# 45 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl.h"
integer RPerl__diag(string message);
integer RPerl__verbose(string message);
integer RPerl__warning(string message);


class RPerl {
public:


    static integer diag(string message) { return RPerl__diag(message); };
    static integer verbose(string message) { return RPerl__verbose(message); };
    static integer warning(string message) { return RPerl__warning(message); };
};
# 68 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl.h"
integer RPerl__MODE_ID() { return 2; }
# 5 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl.cpp" 2
# 87 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl.cpp"
integer RPerl__diag(string message)
{
        dSP;
        int retcnt;
        int retval;

        ENTER;
        SAVETMPS;
        PUSHMARK(SP); XPUSHs(newSVpv(message.c_str(), 0)); PUTBACK;
        retcnt = call_pv("RPerl::diag", G_SCALAR);
        SPAGAIN;
        if (retcnt != 1) { croak("RPerl::diag(message) return count is %ld, expected 1, croaking", retcnt); }
        retval = POPi; PUTBACK;

        LEAVE;

        return retval;
}

integer RPerl__verbose(string message)
{
        dSP;
        int retcnt;
        int retval;

        ENTER;
        SAVETMPS;
        PUSHMARK(SP); XPUSHs(newSVpv(message.c_str(), 0)); PUTBACK;
        retcnt = call_pv("RPerl::verbose", G_SCALAR);
        SPAGAIN;
        if (retcnt != 1) { croak("RPerl::verbose(message) return count is %ld, expected 1, croaking", retcnt); }
        retval = POPi; PUTBACK;

        LEAVE;

        return retval;
}

integer RPerl__warning(string message)
{
        dSP;
        int retcnt;
        int retval;

        ENTER;
        SAVETMPS;
        PUSHMARK(SP); XPUSHs(newSVpv(message.c_str(), 0)); PUTBACK;
        retcnt = call_pv("RPerl::warning", G_SCALAR);
        SPAGAIN;
        if (retcnt != 1) { croak("RPerl::warning(message) return count is %ld, expected 1, croaking", retcnt); }
        retval = POPi; PUTBACK;

        LEAVE;

        return retval;
}
# 9 "lib/MathPerl/LinearAlgebra/AddVectorVector.h" 2
# 1 "lib/MathPerl/Operation.cpp" 1

using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/Operation.h" 1

using std::cout; using std::cerr; using std::endl;






# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/CompileUnit/Module/Class.cpp" 1

using std::cout; using std::cerr; using std::endl;






# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/CompileUnit/Module/Class.h" 1

using std::cout; using std::cerr; using std::endl;
# 60 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/CompileUnit/Module/Class.h"
class RPerl__CompileUnit__Module__Class__CPP
{
public:





    RPerl__CompileUnit__Module__Class__CPP() {}
    ~RPerl__CompileUnit__Module__Class__CPP() {}


    virtual string myclassname() { return (const string) "RPerl::CompileUnit::Module::Class"; }




};




string classname(RPerl__CompileUnit__Module__Class__CPP* my_object) { return my_object->myclassname(); }
# 10 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/CompileUnit/Module/Class.cpp" 2
# 10 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/Operation.h" 2
# 22 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/Operation.h"
class MathPerl__Operation : public RPerl__CompileUnit__Module__Class__CPP {
public:



    MathPerl__Operation() {}
    ~MathPerl__Operation() {}


    virtual string myclassname() { return (const string) "MathPerl::Operation"; }
};



typedef std::unique_ptr<MathPerl__Operation> MathPerl__Operation_ptr;
typedef std::vector<MathPerl__Operation_ptr> MathPerl__Operation_arrayref;
typedef std::unordered_map<string, MathPerl__Operation_ptr> MathPerl__Operation_hashref;
typedef std::unordered_map<string, MathPerl__Operation_ptr>::iterator MathPerl__Operation_hashref_iterator;


integer MathPerl__Operation__MODE_ID() { return 2; }
# 9 "lib/MathPerl/Operation.cpp" 2
# 10 "lib/MathPerl/LinearAlgebra/AddVectorVector.h" 2
# 1 "lib/MathPerl/DataStructure/Vector.cpp" 1

using std::cout; using std::cerr; using std::endl;





# 1 "lib/MathPerl/DataStructure/Vector.h" 1

using std::cout; using std::cerr; using std::endl;






# 1 "lib/MathPerl/DataStructure.cpp" 1

using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/DataStructure.h" 1

using std::cout; using std::cerr; using std::endl;






# 1 "/home/wbraswell/austin_perl_mongers/rperl/rperl-latest/lib/RPerl/CompileUnit/Module/Class.cpp" 1

using std::cout; using std::cerr; using std::endl;
# 10 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/DataStructure.h" 2
# 22 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/DataStructure.h"
class MathPerl__DataStructure : public RPerl__CompileUnit__Module__Class__CPP {
public:



    MathPerl__DataStructure() {}
    ~MathPerl__DataStructure() {}


    virtual string myclassname() { return (const string) "MathPerl::DataStructure"; }
};



typedef std::unique_ptr<MathPerl__DataStructure> MathPerl__DataStructure_ptr;
typedef std::vector<MathPerl__DataStructure_ptr> MathPerl__DataStructure_arrayref;
typedef std::unordered_map<string, MathPerl__DataStructure_ptr> MathPerl__DataStructure_hashref;
typedef std::unordered_map<string, MathPerl__DataStructure_ptr>::iterator MathPerl__DataStructure_hashref_iterator;


integer MathPerl__DataStructure__MODE_ID() { return 2; }
# 9 "lib/MathPerl/DataStructure.cpp" 2
# 10 "lib/MathPerl/DataStructure/Vector.h" 2
# 22 "lib/MathPerl/DataStructure/Vector.h"
class MathPerl__DataStructure__Vector : public MathPerl__DataStructure {
public:

    number_arrayref head;




    number_arrayref get_head() { cout << "in Vector.h get_head()..." << endl; return this->head; }
    void set_head(number_arrayref head_new) { this->head = head_new; }


    MathPerl__DataStructure__Vector() { cout << "in Vector.h Vector() constructor..." << endl; }
    ~MathPerl__DataStructure__Vector() {}


    virtual string myclassname() { return (const string) "MathPerl::DataStructure::Vector"; }


    string To_string();
};



typedef std::unique_ptr<MathPerl__DataStructure__Vector> MathPerl__DataStructure__Vector_ptr;
typedef std::vector<MathPerl__DataStructure__Vector_ptr> MathPerl__DataStructure__Vector_arrayref;
typedef std::unordered_map<string, MathPerl__DataStructure__Vector_ptr> MathPerl__DataStructure__Vector_hashref;
typedef std::unordered_map<string, MathPerl__DataStructure__Vector_ptr>::iterator MathPerl__DataStructure__Vector_hashref_iterator;



string MathPerl__DataStructure__Vector__Vector_to_string(MathPerl__DataStructure__Vector* input_vector_rawptr);





integer MathPerl__DataStructure__Vector__MODE_ID() { return 2; }
# 9 "lib/MathPerl/DataStructure/Vector.cpp" 2
# 22 "lib/MathPerl/DataStructure/Vector.cpp"
string MathPerl__DataStructure__Vector::To_string() {
    cout << "in Vector.cpp MathPerl__DataStructure__Vector::To_string()..." << endl;
    return number_arrayref_to_string(this->head);
}
# 34 "lib/MathPerl/DataStructure/Vector.cpp"
string MathPerl__DataStructure__Vector__Vector_to_string(MathPerl__DataStructure__Vector* input_vector_rawptr) {
    cout << "in Vector.cpp MathPerl__DataStructure__Vector__Vector_to_string() rawptr..." << endl;
    return number_arrayref_to_string(input_vector_rawptr->head);
}
# 11 "lib/MathPerl/LinearAlgebra/AddVectorVector.h" 2



# 1 "lib/MathPerl/Arithmetic/ApproximatelyEqual.cpp" 1

using std::cout; using std::cerr; using std::endl;





# 1 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/Arithmetic/ApproximatelyEqual.h" 1

using std::cout; using std::cerr; using std::endl;






# 1 "lib/MathPerl/Operation.cpp" 1

using std::cout; using std::cerr; using std::endl;
# 10 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/Arithmetic/ApproximatelyEqual.h" 2
# 22 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/lib/MathPerl/Arithmetic/ApproximatelyEqual.h"
class MathPerl__Arithmetic__ApproximatelyEqual : public MathPerl__Operation {
public:



    MathPerl__Arithmetic__ApproximatelyEqual() {}
    ~MathPerl__Arithmetic__ApproximatelyEqual() {}


    virtual string myclassname() { return (const string) "MathPerl::Arithmetic::ApproximatelyEqual"; }
};



typedef std::unique_ptr<MathPerl__Arithmetic__ApproximatelyEqual> MathPerl__Arithmetic__ApproximatelyEqual_ptr;
typedef std::vector<MathPerl__Arithmetic__ApproximatelyEqual_ptr> MathPerl__Arithmetic__ApproximatelyEqual_arrayref;
typedef std::unordered_map<string, MathPerl__Arithmetic__ApproximatelyEqual_ptr> MathPerl__Arithmetic__ApproximatelyEqual_hashref;
typedef std::unordered_map<string, MathPerl__Arithmetic__ApproximatelyEqual_ptr>::iterator MathPerl__Arithmetic__ApproximatelyEqual_hashref_iterator;


boolean MathPerl__Arithmetic__ApproximatelyEqual__approximately_equal(number input_0, number input_1);





integer MathPerl__Arithmetic__ApproximatelyEqual__MODE_ID() { return 2; }
# 9 "lib/MathPerl/Arithmetic/ApproximatelyEqual.cpp" 2
# 22 "lib/MathPerl/Arithmetic/ApproximatelyEqual.cpp"
boolean MathPerl__Arithmetic__ApproximatelyEqual__approximately_equal(number input_0, number input_1) {
    if ((abs (input_0 - input_1)) <= DBL_EPSILON ) {
        return 1;
    }
    else {
        return 0;
    }
}
# 15 "lib/MathPerl/LinearAlgebra/AddVectorVector.h" 2
# 27 "lib/MathPerl/LinearAlgebra/AddVectorVector.h"
class MathPerl__LinearAlgebra__AddVectorVector : public MathPerl__Operation {
public:



    MathPerl__LinearAlgebra__AddVectorVector() {}
    ~MathPerl__LinearAlgebra__AddVectorVector() {}


    virtual string myclassname() { return (const string) "MathPerl::LinearAlgebra::AddVectorVector"; }
};



typedef std::unique_ptr<MathPerl__LinearAlgebra__AddVectorVector> MathPerl__LinearAlgebra__AddVectorVector_ptr;
typedef std::vector<MathPerl__LinearAlgebra__AddVectorVector_ptr> MathPerl__LinearAlgebra__AddVectorVector_arrayref;
typedef std::unordered_map<string, MathPerl__LinearAlgebra__AddVectorVector_ptr> MathPerl__LinearAlgebra__AddVectorVector_hashref;
typedef std::unordered_map<string, MathPerl__LinearAlgebra__AddVectorVector_ptr>::iterator MathPerl__LinearAlgebra__AddVectorVector_hashref_iterator;





MathPerl__DataStructure__Vector_ptr MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector(MathPerl__DataStructure__Vector input_0, MathPerl__DataStructure__Vector input_1);
number_arrayref MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw(number_arrayref input_0, number_arrayref input_1);
# 61 "lib/MathPerl/LinearAlgebra/AddVectorVector.h"
integer MathPerl__LinearAlgebra__AddVectorVector__MODE_ID() { return 2; }
# 9 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/_Inline/build/eval_511_6b51/Filters27149.c" 2
# 83 "/home/wbraswell/austin_perl_mongers/mathperl/mathperl-latest/_Inline/build/eval_511_6b51/Filters27149.c"
MathPerl__DataStructure__Vector_ptr MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector(MathPerl__DataStructure__Vector input_0, MathPerl__DataStructure__Vector input_1) {
    MathPerl__DataStructure__Vector_ptr return_value(new MathPerl__DataStructure__Vector);
    return_value->head = MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw(input_0.head, input_1.head);
    return return_value;
}

number_arrayref MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw(number_arrayref input_0, number_arrayref input_1) {
    integer i;
    integer input_0_dimensionality = input_0.size();
    integer input_1_dimensionality = input_1.size();

    cout << "in AddVectorVector.cpp MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw(), have input_0_dimensionality = " << input_0_dimensionality << endl;
    cout << "in AddVectorVector.cpp MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw(), have input_1_dimensionality = " << input_1_dimensionality << endl;






    number_arrayref return_value;
    return_value.resize(5);

    for ( i = 0; i < input_0_dimensionality; i++ ) {
        return_value[i] = input_0[i] + input_1[i];
    }
    return return_value;
}

#line 3391 "eval_511_6b51.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 3533 "eval_511_6b51.c"

XS_EUPXS(XS_RPerl__CompileUnit__Module__Class__CPP_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_RPerl__CompileUnit__Module__Class__CPP_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	RPerl__CompileUnit__Module__Class__CPP *	RETVAL;

	RETVAL = new RPerl__CompileUnit__Module__Class__CPP();
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_RPerl__CompileUnit__Module__Class__CPP_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_RPerl__CompileUnit__Module__Class__CPP_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	RPerl__CompileUnit__Module__Class__CPP *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (RPerl__CompileUnit__Module__Class__CPP *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "RPerl::CompileUnit::Module::Class::CPP::DESTROY() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_RPerl__CompileUnit__Module__Class__CPP_myclassname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_RPerl__CompileUnit__Module__Class__CPP_myclassname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	RPerl__CompileUnit__Module__Class__CPP *	THIS;
	string	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (RPerl__CompileUnit__Module__Class__CPP *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "RPerl::CompileUnit::Module::Class::CPP::myclassname() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = THIS->myclassname();
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__Operation_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__Operation_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	MathPerl__Operation *	RETVAL;

	RETVAL = new MathPerl__Operation();
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__Operation_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__Operation_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__Operation *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__Operation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::Operation::DESTROY() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_MathPerl__Operation_myclassname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__Operation_myclassname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__Operation *	THIS;
	string	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__Operation *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::Operation::myclassname() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = THIS->myclassname();
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__DataStructure_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	MathPerl__DataStructure *	RETVAL;

	RETVAL = new MathPerl__DataStructure();
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__DataStructure_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__DataStructure *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__DataStructure *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::DataStructure::DESTROY() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_MathPerl__DataStructure_myclassname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure_myclassname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__DataStructure *	THIS;
	string	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__DataStructure *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::DataStructure::myclassname() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = THIS->myclassname();
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__DataStructure__Vector_get_head); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure__Vector_get_head)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__DataStructure__Vector *	THIS;
	number_arrayref	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__DataStructure__Vector *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::DataStructure::Vector::get_head() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = THIS->get_head();
	ST(0) = sv_newmortal();
	XS_pack_number_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__DataStructure__Vector_set_head); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure__Vector_set_head)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, head_new");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	number_arrayref	head_new = XS_unpack_number_arrayref(ST(1))
;
#line 3434 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 3785 "eval_511_6b51.c"
	MathPerl__DataStructure__Vector *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__DataStructure__Vector *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::DataStructure::Vector::set_head() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;
#line 3436 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	THIS->set_head(head_new);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 3806 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_MathPerl__DataStructure__Vector_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure__Vector_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	MathPerl__DataStructure__Vector *	RETVAL;

	RETVAL = new MathPerl__DataStructure__Vector();
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__DataStructure__Vector_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure__Vector_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__DataStructure__Vector *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__DataStructure__Vector *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::DataStructure::Vector::DESTROY() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_MathPerl__DataStructure__Vector_myclassname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure__Vector_myclassname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__DataStructure__Vector *	THIS;
	string	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__DataStructure__Vector *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::DataStructure::Vector::myclassname() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = THIS->myclassname();
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__DataStructure__Vector_To_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__DataStructure__Vector_To_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__DataStructure__Vector *	THIS;
	string	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__DataStructure__Vector *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::DataStructure::Vector::To_string() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = THIS->To_string();
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__Arithmetic__ApproximatelyEqual_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__Arithmetic__ApproximatelyEqual_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	MathPerl__Arithmetic__ApproximatelyEqual *	RETVAL;

	RETVAL = new MathPerl__Arithmetic__ApproximatelyEqual();
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__Arithmetic__ApproximatelyEqual_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__Arithmetic__ApproximatelyEqual_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__Arithmetic__ApproximatelyEqual *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__Arithmetic__ApproximatelyEqual *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::Arithmetic::ApproximatelyEqual::DESTROY() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_MathPerl__Arithmetic__ApproximatelyEqual_myclassname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__Arithmetic__ApproximatelyEqual_myclassname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__Arithmetic__ApproximatelyEqual *	THIS;
	string	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__Arithmetic__ApproximatelyEqual *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::Arithmetic::ApproximatelyEqual::myclassname() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = THIS->myclassname();
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__LinearAlgebra__AddVectorVector_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__LinearAlgebra__AddVectorVector_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	MathPerl__LinearAlgebra__AddVectorVector *	RETVAL;

	RETVAL = new MathPerl__LinearAlgebra__AddVectorVector();
	ST(0) = sv_newmortal();
    sv_setref_pv( ST(0), CLASS, (void*)RETVAL );
    }
    XSRETURN(1);
}


XS_EUPXS(XS_MathPerl__LinearAlgebra__AddVectorVector_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__LinearAlgebra__AddVectorVector_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__LinearAlgebra__AddVectorVector *	THIS;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__LinearAlgebra__AddVectorVector *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::LinearAlgebra::AddVectorVector::DESTROY() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	delete THIS;
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_MathPerl__LinearAlgebra__AddVectorVector_myclassname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_MathPerl__LinearAlgebra__AddVectorVector_myclassname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MathPerl__LinearAlgebra__AddVectorVector *	THIS;
	string	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        THIS = (MathPerl__LinearAlgebra__AddVectorVector *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "MathPerl::LinearAlgebra::AddVectorVector::myclassname() -- THIS is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = THIS->myclassname();
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_SvBOKp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_SvBOKp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl_SvBOKp(input_sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_SvUIOKp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_SvUIOKp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl_SvUIOKp(input_sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_SvIOKp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_SvIOKp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl_SvIOKp(input_sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_SvNOKp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_SvNOKp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl_SvNOKp(input_sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_SvCOKp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_SvCOKp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl_SvCOKp(input_sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_SvPOKp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_SvPOKp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl_SvPOKp(input_sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_SvAROKp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_SvAROKp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_avref");
    {
	SV *	input_avref = ST(0)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl_SvAROKp(input_avref);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_SvHROKp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_SvHROKp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_hv_ref");
    {
	SV *	input_hv_ref = ST(0)
;
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl_SvHROKp(input_hv_ref);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl_object_property_init); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl_object_property_init)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "initee");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	initee = ST(0)
;
#line 3527 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 4215 "eval_511_6b51.c"
#line 3529 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	RPerl_object_property_init(initee);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 4226 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_RPerl__HelperFunctions__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__HelperFunctions__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl__HelperFunctions__MODE_ID();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__DataType__Boolean__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataType__Boolean__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl__DataType__Boolean__MODE_ID();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_unpack_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_boolean)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	boolean	RETVAL;

	RETVAL = XS_unpack_boolean(input_sv);
	ST(0) = sv_newmortal();
	XS_pack_boolean(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_boolean)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_sv, input_boolean");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_sv = ST(0)
;
	boolean	input_boolean = XS_unpack_boolean(ST(1))
;
#line 3554 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 4301 "eval_511_6b51.c"
#line 3556 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_boolean(output_sv,input_boolean);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 4312 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_boolean_to_integer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_boolean_to_integer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_boolean");
    {
	boolean	input_boolean = XS_unpack_boolean(ST(0))
;
	integer	RETVAL;

	RETVAL = boolean_to_integer(input_boolean);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_boolean_to_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_boolean_to_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_boolean");
    {
	boolean	input_boolean = XS_unpack_boolean(ST(0))
;
	number	RETVAL;

	RETVAL = boolean_to_number(input_boolean);
	ST(0) = sv_newmortal();
	XS_pack_number(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_boolean_to_character); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_boolean_to_character)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_boolean");
    {
	boolean	input_boolean = XS_unpack_boolean(ST(0))
;
	character	RETVAL;

	RETVAL = boolean_to_character(input_boolean);
	ST(0) = sv_newmortal();
	XS_pack_character(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_boolean_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_boolean_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_boolean");
    {
	boolean	input_boolean = XS_unpack_boolean(ST(0))
;
	string	RETVAL;

	RETVAL = boolean_to_string(input_boolean);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_boolean__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_boolean__typetest0)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	boolean	RETVAL;

	RETVAL = boolean__typetest0();
	ST(0) = sv_newmortal();
	XS_pack_boolean(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_boolean__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_boolean__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_boolean");
    {
	boolean	lucky_boolean = XS_unpack_boolean(ST(0))
;
	boolean	RETVAL;

	RETVAL = boolean__typetest1(lucky_boolean);
	ST(0) = sv_newmortal();
	XS_pack_boolean(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__DataType__UnsignedInteger__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataType__UnsignedInteger__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl__DataType__UnsignedInteger__MODE_ID();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__DataType__Integer__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataType__Integer__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl__DataType__Integer__MODE_ID();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_unpack_integer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_integer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	integer	RETVAL;

	RETVAL = XS_unpack_integer(input_sv);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_integer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_integer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_sv, input_integer");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_sv = ST(0)
;
	integer	input_integer = XS_unpack_integer(ST(1))
;
#line 3604 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 4499 "eval_511_6b51.c"
#line 3606 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_integer(output_sv,input_integer);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 4510 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_integer_to_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_to_boolean)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_integer");
    {
	integer	input_integer = XS_unpack_integer(ST(0))
;
	boolean	RETVAL;

	RETVAL = integer_to_boolean(input_integer);
	ST(0) = sv_newmortal();
	XS_pack_boolean(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_to_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_to_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_integer");
    {
	integer	input_integer = XS_unpack_integer(ST(0))
;
	number	RETVAL;

	RETVAL = integer_to_number(input_integer);
	ST(0) = sv_newmortal();
	XS_pack_number(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_to_character); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_to_character)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_integer");
    {
	integer	input_integer = XS_unpack_integer(ST(0))
;
	character	RETVAL;

	RETVAL = integer_to_character(input_integer);
	ST(0) = sv_newmortal();
	XS_pack_character(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_integer");
    {
	integer	input_integer = XS_unpack_integer(ST(0))
;
	string	RETVAL;

	RETVAL = integer_to_string(input_integer);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_to_string_CPPTYPES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_to_string_CPPTYPES)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_integer");
    {
	integer	input_integer = XS_unpack_integer(ST(0))
;
	string	RETVAL;

	RETVAL = integer_to_string_CPPTYPES(input_integer);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer__typetest0)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = integer__typetest0();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_integer");
    {
	integer	lucky_integer = XS_unpack_integer(ST(0))
;
	integer	RETVAL;

	RETVAL = integer__typetest1(lucky_integer);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__DataType__Number__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataType__Number__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl__DataType__Number__MODE_ID();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_unpack_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	number	RETVAL;

	RETVAL = XS_unpack_number(input_sv);
	ST(0) = sv_newmortal();
	XS_pack_number(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_number)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_sv, input_number");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_sv = ST(0)
;
	number	input_number = XS_unpack_number(ST(1))
;
#line 3655 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 4699 "eval_511_6b51.c"
#line 3657 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_number(output_sv,input_number);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 4710 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_number_to_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_to_boolean)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_number");
    {
	number	input_number = XS_unpack_number(ST(0))
;
	boolean	RETVAL;

	RETVAL = number_to_boolean(input_number);
	ST(0) = sv_newmortal();
	XS_pack_boolean(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_to_integer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_to_integer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_number");
    {
	number	input_number = XS_unpack_number(ST(0))
;
	integer	RETVAL;

	RETVAL = number_to_integer(input_number);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_to_character); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_to_character)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_number");
    {
	number	input_number = XS_unpack_number(ST(0))
;
	character	RETVAL;

	RETVAL = number_to_character(input_number);
	ST(0) = sv_newmortal();
	XS_pack_character(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_number");
    {
	number	input_number = XS_unpack_number(ST(0))
;
	string	RETVAL;

	RETVAL = number_to_string(input_number);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_to_string_CPPTYPES); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_to_string_CPPTYPES)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_number");
    {
	number	input_number = XS_unpack_number(ST(0))
;
	string	RETVAL;

	RETVAL = number_to_string_CPPTYPES(input_number);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number__typetest0)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	number	RETVAL;

	RETVAL = number__typetest0();
	ST(0) = sv_newmortal();
	XS_pack_number(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_number");
    {
	number	lucky_number = XS_unpack_number(ST(0))
;
	number	RETVAL;

	RETVAL = number__typetest1(lucky_number);
	ST(0) = sv_newmortal();
	XS_pack_number(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__DataType__Character__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataType__Character__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl__DataType__Character__MODE_ID();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_unpack_character); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_character)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	character	RETVAL;

	RETVAL = XS_unpack_character(input_sv);
	ST(0) = sv_newmortal();
	XS_pack_character(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_character); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_character)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_sv, input_character");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_sv = ST(0)
;
	character	input_character = XS_unpack_character(ST(1))
;
#line 3706 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 4899 "eval_511_6b51.c"
#line 3708 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_character(output_sv,input_character);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 4910 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_character_to_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_character_to_boolean)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_character");
    {
	character	input_character = XS_unpack_character(ST(0))
;
	boolean	RETVAL;

	RETVAL = character_to_boolean(input_character);
	ST(0) = sv_newmortal();
	XS_pack_boolean(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_character_to_integer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_character_to_integer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_character");
    {
	character	input_character = XS_unpack_character(ST(0))
;
	integer	RETVAL;

	RETVAL = character_to_integer(input_character);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_character_to_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_character_to_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_character");
    {
	character	input_character = XS_unpack_character(ST(0))
;
	number	RETVAL;

	RETVAL = character_to_number(input_character);
	ST(0) = sv_newmortal();
	XS_pack_number(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_character_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_character_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_character");
    {
	character	input_character = XS_unpack_character(ST(0))
;
	string	RETVAL;

	RETVAL = character_to_string(input_character);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_character__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_character__typetest0)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	character	RETVAL;

	RETVAL = character__typetest0();
	ST(0) = sv_newmortal();
	XS_pack_character(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_character__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_character__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_character");
    {
	character	lucky_character = XS_unpack_character(ST(0))
;
	character	RETVAL;

	RETVAL = character__typetest1(lucky_character);
	ST(0) = sv_newmortal();
	XS_pack_character(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__DataType__String__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataType__String__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	int	RETVAL;
	dXSTARG;

	RETVAL = RPerl__DataType__String__MODE_ID();
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_unpack_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_sv");
    {
	SV *	input_sv = ST(0)
;
	string	RETVAL;

	RETVAL = XS_unpack_string(input_sv);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_string)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_sv, input_string");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_sv = ST(0)
;
	string	input_string = XS_unpack_string(ST(1))
;
#line 3753 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5080 "eval_511_6b51.c"
#line 3755 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_string(output_sv,input_string);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5091 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_string_to_boolean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_to_boolean)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_string");
    {
	string	input_string = XS_unpack_string(ST(0))
;
	boolean	RETVAL;

	RETVAL = string_to_boolean(input_string);
	ST(0) = sv_newmortal();
	XS_pack_boolean(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_to_integer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_to_integer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_string");
    {
	string	input_string = XS_unpack_string(ST(0))
;
	integer	RETVAL;

	RETVAL = string_to_integer(input_string);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_to_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_to_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_string");
    {
	string	input_string = XS_unpack_string(ST(0))
;
	number	RETVAL;

	RETVAL = string_to_number(input_string);
	ST(0) = sv_newmortal();
	XS_pack_number(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_to_character); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_to_character)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_string");
    {
	string	input_string = XS_unpack_string(ST(0))
;
	character	RETVAL;

	RETVAL = string_to_character(input_string);
	ST(0) = sv_newmortal();
	XS_pack_character(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_string");
    {
	string	input_string = XS_unpack_string(ST(0))
;
	string	RETVAL;

	RETVAL = string_to_string(input_string);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string__typetest0)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	string	RETVAL;

	RETVAL = string__typetest0();
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_string");
    {
	string	lucky_string = XS_unpack_string(ST(0))
;
	string	RETVAL;

	RETVAL = string__typetest1(lucky_string);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_arrayref_arrayref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref_arrayref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_integer_arrayref_arrayref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_integer_arrayref_arrayref = ST(0)
;
#line 3796 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5242 "eval_511_6b51.c"
#line 3798 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	integer_arrayref_arrayref_CHECK(possible_integer_arrayref_arrayref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5253 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_integer_arrayref_arrayref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref_arrayref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_integer_arrayref_arrayref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_integer_arrayref_arrayref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 3814 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5277 "eval_511_6b51.c"
#line 3816 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	integer_arrayref_arrayref_CHECKTRACE(possible_integer_arrayref_arrayref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5288 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_number_arrayref_arrayref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_arrayref_arrayref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_number_arrayref_arrayref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_number_arrayref_arrayref = ST(0)
;
#line 3830 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5308 "eval_511_6b51.c"
#line 3832 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	number_arrayref_arrayref_CHECK(possible_number_arrayref_arrayref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5319 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_number_arrayref_arrayref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_arrayref_arrayref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_number_arrayref_arrayref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_number_arrayref_arrayref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 3848 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5343 "eval_511_6b51.c"
#line 3850 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	number_arrayref_arrayref_CHECKTRACE(possible_number_arrayref_arrayref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5354 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_string_arrayref_arrayref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_arrayref_arrayref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_string_arrayref_arrayref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_string_arrayref_arrayref = ST(0)
;
#line 3864 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5374 "eval_511_6b51.c"
#line 3866 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	string_arrayref_arrayref_CHECK(possible_string_arrayref_arrayref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5385 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_string_arrayref_arrayref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_arrayref_arrayref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_string_arrayref_arrayref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_string_arrayref_arrayref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 3882 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5409 "eval_511_6b51.c"
#line 3884 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	string_arrayref_arrayref_CHECKTRACE(possible_string_arrayref_arrayref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5420 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_RPerl__DataStructure__Array__SubTypes__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataStructure__Array__SubTypes__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = RPerl__DataStructure__Array__SubTypes__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_unpack_integer_arrayref_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_integer_arrayref_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_avref_avref");
    {
	SV *	input_avref_avref = ST(0)
;
	integer_arrayref_arrayref	RETVAL;

	RETVAL = XS_unpack_integer_arrayref_arrayref(input_avref_avref);
	ST(0) = sv_newmortal();
	XS_pack_integer_arrayref_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_integer_arrayref_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_integer_arrayref_arrayref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_avref_avref, input_vector_vector");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_avref_avref = ST(0)
;
	integer_arrayref_arrayref	input_vector_vector = XS_unpack_integer_arrayref_arrayref(ST(1))
;
#line 3906 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5478 "eval_511_6b51.c"
#line 3908 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_integer_arrayref_arrayref(output_avref_avref,input_vector_vector);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5489 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_integer_arrayref_arrayref_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref_arrayref_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_vector_vector");
    {
	integer_arrayref_arrayref	input_vector_vector = XS_unpack_integer_arrayref_arrayref(ST(0))
;
	string	RETVAL;

	RETVAL = integer_arrayref_arrayref_to_string(input_vector_vector);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_arrayref_arrayref__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref_arrayref__typetest0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_integers");
    {
	integer_arrayref_arrayref	lucky_integers = XS_unpack_integer_arrayref_arrayref(ST(0))
;
	string	RETVAL;

	RETVAL = integer_arrayref_arrayref__typetest0(lucky_integers);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_arrayref_arrayref__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref_arrayref__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "my_size");
    {
	integer	my_size = XS_unpack_integer(ST(0))
;
	integer_arrayref_arrayref	RETVAL;

	RETVAL = integer_arrayref_arrayref__typetest1(my_size);
	ST(0) = sv_newmortal();
	XS_pack_integer_arrayref_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_arrayref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_integer_arrayref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_integer_arrayref = ST(0)
;
#line 3934 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5566 "eval_511_6b51.c"
#line 3936 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	integer_arrayref_CHECK(possible_integer_arrayref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5577 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_integer_arrayref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_integer_arrayref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_integer_arrayref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 3952 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5601 "eval_511_6b51.c"
#line 3954 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	integer_arrayref_CHECKTRACE(possible_integer_arrayref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5612 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_number_arrayref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_arrayref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_number_arrayref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_number_arrayref = ST(0)
;
#line 3968 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5632 "eval_511_6b51.c"
#line 3970 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	number_arrayref_CHECK(possible_number_arrayref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5643 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_number_arrayref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_arrayref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_number_arrayref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_number_arrayref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 3986 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5667 "eval_511_6b51.c"
#line 3988 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	number_arrayref_CHECKTRACE(possible_number_arrayref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5678 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_string_arrayref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_arrayref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_string_arrayref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_string_arrayref = ST(0)
;
#line 4002 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5698 "eval_511_6b51.c"
#line 4004 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	string_arrayref_CHECK(possible_string_arrayref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5709 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_string_arrayref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_arrayref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_string_arrayref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_string_arrayref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 4020 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5733 "eval_511_6b51.c"
#line 4022 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	string_arrayref_CHECKTRACE(possible_string_arrayref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5744 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_RPerl__DataStructure__Array__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataStructure__Array__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = RPerl__DataStructure__Array__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_unpack_integer_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_integer_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_avref");
    {
	SV *	input_avref = ST(0)
;
	integer_arrayref	RETVAL;

	RETVAL = XS_unpack_integer_arrayref(input_avref);
	ST(0) = sv_newmortal();
	XS_pack_integer_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_integer_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_integer_arrayref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_avref, input_vector");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_avref = ST(0)
;
	integer_arrayref	input_vector = XS_unpack_integer_arrayref(ST(1))
;
#line 4044 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5802 "eval_511_6b51.c"
#line 4046 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_integer_arrayref(output_avref,input_vector);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5813 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_XS_unpack_number_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_number_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_avref");
    {
	SV *	input_avref = ST(0)
;
	number_arrayref	RETVAL;

	RETVAL = XS_unpack_number_arrayref(input_avref);
	ST(0) = sv_newmortal();
	XS_pack_number_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_number_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_number_arrayref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_avref, input_vector");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_avref = ST(0)
;
	number_arrayref	input_vector = XS_unpack_number_arrayref(ST(1))
;
#line 4065 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5854 "eval_511_6b51.c"
#line 4067 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_number_arrayref(output_avref,input_vector);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5865 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_XS_unpack_string_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_string_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_avref");
    {
	SV *	input_avref = ST(0)
;
	string_arrayref	RETVAL;

	RETVAL = XS_unpack_string_arrayref(input_avref);
	ST(0) = sv_newmortal();
	XS_pack_string_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_string_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_string_arrayref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_avref, input_vector");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_avref = ST(0)
;
	string_arrayref	input_vector = XS_unpack_string_arrayref(ST(1))
;
#line 4086 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 5906 "eval_511_6b51.c"
#line 4088 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_string_arrayref(output_avref,input_vector);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 5917 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_integer_arrayref_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_vector");
    {
	integer_arrayref	input_vector = XS_unpack_integer_arrayref(ST(0))
;
	string	RETVAL;

	RETVAL = integer_arrayref_to_string(input_vector);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_arrayref_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_arrayref_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_vector");
    {
	number_arrayref	input_vector = XS_unpack_number_arrayref(ST(0))
;
	string	RETVAL;

	RETVAL = number_arrayref_to_string(input_vector);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_arrayref_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_arrayref_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_vector");
    {
	string_arrayref	input_vector = XS_unpack_string_arrayref(ST(0))
;
	string	RETVAL;

	RETVAL = string_arrayref_to_string(input_vector);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_arrayref__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref__typetest0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_integers");
    {
	integer_arrayref	lucky_integers = XS_unpack_integer_arrayref(ST(0))
;
	string	RETVAL;

	RETVAL = integer_arrayref__typetest0(lucky_integers);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_arrayref__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_arrayref__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "my_size");
    {
	integer	my_size = XS_unpack_integer(ST(0))
;
	integer_arrayref	RETVAL;

	RETVAL = integer_arrayref__typetest1(my_size);
	ST(0) = sv_newmortal();
	XS_pack_integer_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_arrayref__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_arrayref__typetest0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_numbers");
    {
	number_arrayref	lucky_numbers = XS_unpack_number_arrayref(ST(0))
;
	string	RETVAL;

	RETVAL = number_arrayref__typetest0(lucky_numbers);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_arrayref__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_arrayref__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "my_size");
    {
	integer	my_size = XS_unpack_integer(ST(0))
;
	number_arrayref	RETVAL;

	RETVAL = number_arrayref__typetest1(my_size);
	ST(0) = sv_newmortal();
	XS_pack_number_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_arrayref__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_arrayref__typetest0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "people");
    {
	string_arrayref	people = XS_unpack_string_arrayref(ST(0))
;
	string	RETVAL;

	RETVAL = string_arrayref__typetest0(people);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_arrayref__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_arrayref__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "my_size");
    {
	integer	my_size = XS_unpack_integer(ST(0))
;
	string_arrayref	RETVAL;

	RETVAL = string_arrayref__typetest1(my_size);
	ST(0) = sv_newmortal();
	XS_pack_string_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_hashref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_hashref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_integer_hashref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_integer_hashref = ST(0)
;
#line 4138 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6108 "eval_511_6b51.c"
#line 4140 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	integer_hashref_CHECK(possible_integer_hashref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6119 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_integer_hashref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_hashref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_integer_hashref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_integer_hashref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 4156 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6143 "eval_511_6b51.c"
#line 4158 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	integer_hashref_CHECKTRACE(possible_integer_hashref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6154 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_number_hashref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_hashref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_number_hashref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_number_hashref = ST(0)
;
#line 4172 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6174 "eval_511_6b51.c"
#line 4174 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	number_hashref_CHECK(possible_number_hashref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6185 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_number_hashref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_hashref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_number_hashref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_number_hashref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 4190 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6209 "eval_511_6b51.c"
#line 4192 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	number_hashref_CHECKTRACE(possible_number_hashref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6220 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_string_hashref_CHECK); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_hashref_CHECK)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "possible_string_hashref");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_string_hashref = ST(0)
;
#line 4206 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6240 "eval_511_6b51.c"
#line 4208 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	string_hashref_CHECK(possible_string_hashref);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6251 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_string_hashref_CHECKTRACE); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_hashref_CHECKTRACE)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "possible_string_hashref, variable_name, subroutine_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	possible_string_hashref = ST(0)
;
	char *	variable_name = (char *)SvPV_nolen(ST(1))
;
	char *	subroutine_name = (char *)SvPV_nolen(ST(2))
;
#line 4224 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6275 "eval_511_6b51.c"
#line 4226 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	string_hashref_CHECKTRACE(possible_string_hashref,variable_name,subroutine_name);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6286 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_RPerl__DataStructure__Hash__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__DataStructure__Hash__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = RPerl__DataStructure__Hash__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_unpack_integer_hashref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_integer_hashref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_hv_ref");
    {
	SV *	input_hv_ref = ST(0)
;
	integer_hashref	RETVAL;

	RETVAL = XS_unpack_integer_hashref(input_hv_ref);
	ST(0) = sv_newmortal();
	XS_pack_integer_hashref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_integer_hashref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_integer_hashref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_hv_ref, input_unordered_map");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_hv_ref = ST(0)
;
	integer_hashref	input_unordered_map = XS_unpack_integer_hashref(ST(1))
;
#line 4248 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6344 "eval_511_6b51.c"
#line 4250 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_integer_hashref(output_hv_ref,input_unordered_map);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6355 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_XS_unpack_number_hashref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_number_hashref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_hv_ref");
    {
	SV *	input_hv_ref = ST(0)
;
	number_hashref	RETVAL;

	RETVAL = XS_unpack_number_hashref(input_hv_ref);
	ST(0) = sv_newmortal();
	XS_pack_number_hashref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_number_hashref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_number_hashref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_hv_ref, input_unordered_map");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_hv_ref = ST(0)
;
	number_hashref	input_unordered_map = XS_unpack_number_hashref(ST(1))
;
#line 4269 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6396 "eval_511_6b51.c"
#line 4271 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_number_hashref(output_hv_ref,input_unordered_map);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6407 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_XS_unpack_string_hashref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_unpack_string_hashref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_hv_ref");
    {
	SV *	input_hv_ref = ST(0)
;
	string_hashref	RETVAL;

	RETVAL = XS_unpack_string_hashref(input_hv_ref);
	ST(0) = sv_newmortal();
	XS_pack_string_hashref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_XS_pack_string_hashref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_XS_pack_string_hashref)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "output_hv_ref, input_unordered_map");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	output_hv_ref = ST(0)
;
	string_hashref	input_unordered_map = XS_unpack_string_hashref(ST(1))
;
#line 4290 "eval_511_6b51.xs"
	I32 *	__temp_markstack_ptr;
#line 6448 "eval_511_6b51.c"
#line 4292 "eval_511_6b51.xs"
	__temp_markstack_ptr = PL_markstack_ptr++;
	XS_pack_string_hashref(output_hv_ref,input_unordered_map);
        if (PL_markstack_ptr != __temp_markstack_ptr) {
          /* truly void, because dXSARGS not invoked */
          PL_markstack_ptr = __temp_markstack_ptr;
          XSRETURN_EMPTY; /* return empty stack */
        }
        /* must have used dXSARGS; list context implied */
        return; /* assume stack size is correct */
#line 6459 "eval_511_6b51.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_main_integer_hashref_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_hashref_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_unordered_map");
    {
	integer_hashref	input_unordered_map = XS_unpack_integer_hashref(ST(0))
;
	string	RETVAL;

	RETVAL = integer_hashref_to_string(input_unordered_map);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_hashref_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_hashref_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_unordered_map");
    {
	number_hashref	input_unordered_map = XS_unpack_number_hashref(ST(0))
;
	string	RETVAL;

	RETVAL = number_hashref_to_string(input_unordered_map);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_hashref_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_hashref_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_unordered_map");
    {
	string_hashref	input_unordered_map = XS_unpack_string_hashref(ST(0))
;
	string	RETVAL;

	RETVAL = string_hashref_to_string(input_unordered_map);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_hashref__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_hashref__typetest0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_integers");
    {
	integer_hashref	lucky_integers = XS_unpack_integer_hashref(ST(0))
;
	string	RETVAL;

	RETVAL = integer_hashref__typetest0(lucky_integers);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_integer_hashref__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_integer_hashref__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "my_size");
    {
	integer	my_size = XS_unpack_integer(ST(0))
;
	integer_hashref	RETVAL;

	RETVAL = integer_hashref__typetest1(my_size);
	ST(0) = sv_newmortal();
	XS_pack_integer_hashref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_hashref__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_hashref__typetest0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "lucky_numbers");
    {
	number_hashref	lucky_numbers = XS_unpack_number_hashref(ST(0))
;
	string	RETVAL;

	RETVAL = number_hashref__typetest0(lucky_numbers);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_number_hashref__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_number_hashref__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "my_size");
    {
	integer	my_size = XS_unpack_integer(ST(0))
;
	number_hashref	RETVAL;

	RETVAL = number_hashref__typetest1(my_size);
	ST(0) = sv_newmortal();
	XS_pack_number_hashref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_hashref__typetest0); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_hashref__typetest0)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "people");
    {
	string_hashref	people = XS_unpack_string_hashref(ST(0))
;
	string	RETVAL;

	RETVAL = string_hashref__typetest0(people);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_string_hashref__typetest1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_string_hashref__typetest1)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "my_size");
    {
	integer	my_size = XS_unpack_integer(ST(0))
;
	string_hashref	RETVAL;

	RETVAL = string_hashref__typetest1(my_size);
	ST(0) = sv_newmortal();
	XS_pack_string_hashref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_to_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_to_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_string");
    {
	string	input_string = XS_unpack_string(ST(0))
;
	number	RETVAL;

	RETVAL = to_number(input_string);
	ST(0) = sv_newmortal();
	XS_pack_number(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_To_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_To_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_string");
    {
	string	input_string = XS_unpack_string(ST(0))
;
	string	RETVAL;

	RETVAL = To_string(input_string);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__diag); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__diag)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "message");
    {
	string	message = XS_unpack_string(ST(0))
;
	integer	RETVAL;

	RETVAL = RPerl__diag(message);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__verbose); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__verbose)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "message");
    {
	string	message = XS_unpack_string(ST(0))
;
	integer	RETVAL;

	RETVAL = RPerl__verbose(message);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__warning); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__warning)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "message");
    {
	string	message = XS_unpack_string(ST(0))
;
	integer	RETVAL;

	RETVAL = RPerl__warning(message);
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_RPerl__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_RPerl__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = RPerl__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_classname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_classname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "my_object");
    {
	RPerl__CompileUnit__Module__Class__CPP *	my_object;
	string	RETVAL;

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        my_object = (RPerl__CompileUnit__Module__Class__CPP *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "main::classname() -- my_object is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = classname(my_object);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_MathPerl__Operation__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_MathPerl__Operation__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = MathPerl__Operation__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_MathPerl__DataStructure__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_MathPerl__DataStructure__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = MathPerl__DataStructure__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_MathPerl__DataStructure__Vector__Vector_to_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_MathPerl__DataStructure__Vector__Vector_to_string)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input_vector_rawptr");
    {
	MathPerl__DataStructure__Vector *	input_vector_rawptr;
	string	RETVAL;

    warn ( "in main::MathPerl__DataStructure__Vector__Vector_to_string(), have sv_isobject(ST(0)) = ", sv_isobject(ST(0)) );
    warn ( "in main::MathPerl__DataStructure__Vector__Vector_to_string(), have SvTYPE(SvRV(ST(0))) = ", SvTYPE(SvRV(ST(0))) );

    if (sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG)) {
        input_vector_rawptr = (MathPerl__DataStructure__Vector *)SvIV((SV*)SvRV( ST(0) ));
    }
    else {
        warn ( "main::MathPerl__DataStructure__Vector__Vector_to_string() -- input_vector_rawptr is not a blessed reference" );
        XSRETURN_UNDEF;
    }
;

	RETVAL = MathPerl__DataStructure__Vector__Vector_to_string(input_vector_rawptr);
	ST(0) = sv_newmortal();
	XS_pack_string(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_MathPerl__DataStructure__Vector__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_MathPerl__DataStructure__Vector__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = MathPerl__DataStructure__Vector__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_MathPerl__Arithmetic__ApproximatelyEqual__approximately_equal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_MathPerl__Arithmetic__ApproximatelyEqual__approximately_equal)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "input_0, input_1");
    {
	number	input_0 = XS_unpack_number(ST(0))
;
	number	input_1 = XS_unpack_number(ST(1))
;
	boolean	RETVAL;

	RETVAL = MathPerl__Arithmetic__ApproximatelyEqual__approximately_equal(input_0, input_1);
	ST(0) = sv_newmortal();
	XS_pack_boolean(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_MathPerl__Arithmetic__ApproximatelyEqual__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_MathPerl__Arithmetic__ApproximatelyEqual__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = MathPerl__Arithmetic__ApproximatelyEqual__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "input_0, input_1");
    {
	number_arrayref	input_0 = XS_unpack_number_arrayref(ST(0))
;
	number_arrayref	input_1 = XS_unpack_number_arrayref(ST(1))
;
	number_arrayref	RETVAL;

	RETVAL = MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw(input_0, input_1);
	ST(0) = sv_newmortal();
	XS_pack_number_arrayref(ST(0), RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_main_MathPerl__LinearAlgebra__AddVectorVector__MODE_ID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_main_MathPerl__LinearAlgebra__AddVectorVector__MODE_ID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	integer	RETVAL;

	RETVAL = MathPerl__LinearAlgebra__AddVectorVector__MODE_ID();
	ST(0) = sv_newmortal();
	XS_pack_integer(ST(0), RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_eval_511_6b51); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_eval_511_6b51)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("RPerl::CompileUnit::Module::Class::CPP::new", XS_RPerl__CompileUnit__Module__Class__CPP_new, file);
        newXS("RPerl::CompileUnit::Module::Class::CPP::DESTROY", XS_RPerl__CompileUnit__Module__Class__CPP_DESTROY, file);
        newXS("RPerl::CompileUnit::Module::Class::CPP::myclassname", XS_RPerl__CompileUnit__Module__Class__CPP_myclassname, file);
        newXS("MathPerl::Operation::new", XS_MathPerl__Operation_new, file);
        newXS("MathPerl::Operation::DESTROY", XS_MathPerl__Operation_DESTROY, file);
        newXS("MathPerl::Operation::myclassname", XS_MathPerl__Operation_myclassname, file);
        newXS("MathPerl::DataStructure::new", XS_MathPerl__DataStructure_new, file);
        newXS("MathPerl::DataStructure::DESTROY", XS_MathPerl__DataStructure_DESTROY, file);
        newXS("MathPerl::DataStructure::myclassname", XS_MathPerl__DataStructure_myclassname, file);
        newXS("MathPerl::DataStructure::Vector::get_head", XS_MathPerl__DataStructure__Vector_get_head, file);
        newXS("MathPerl::DataStructure::Vector::set_head", XS_MathPerl__DataStructure__Vector_set_head, file);
        newXS("MathPerl::DataStructure::Vector::new", XS_MathPerl__DataStructure__Vector_new, file);
        newXS("MathPerl::DataStructure::Vector::DESTROY", XS_MathPerl__DataStructure__Vector_DESTROY, file);
        newXS("MathPerl::DataStructure::Vector::myclassname", XS_MathPerl__DataStructure__Vector_myclassname, file);
        newXS("MathPerl::DataStructure::Vector::To_string", XS_MathPerl__DataStructure__Vector_To_string, file);
        newXS("MathPerl::Arithmetic::ApproximatelyEqual::new", XS_MathPerl__Arithmetic__ApproximatelyEqual_new, file);
        newXS("MathPerl::Arithmetic::ApproximatelyEqual::DESTROY", XS_MathPerl__Arithmetic__ApproximatelyEqual_DESTROY, file);
        newXS("MathPerl::Arithmetic::ApproximatelyEqual::myclassname", XS_MathPerl__Arithmetic__ApproximatelyEqual_myclassname, file);
        newXS("MathPerl::LinearAlgebra::AddVectorVector::new", XS_MathPerl__LinearAlgebra__AddVectorVector_new, file);
        newXS("MathPerl::LinearAlgebra::AddVectorVector::DESTROY", XS_MathPerl__LinearAlgebra__AddVectorVector_DESTROY, file);
        newXS("MathPerl::LinearAlgebra::AddVectorVector::myclassname", XS_MathPerl__LinearAlgebra__AddVectorVector_myclassname, file);
        newXS("main::RPerl_SvBOKp", XS_main_RPerl_SvBOKp, file);
        newXS("main::RPerl_SvUIOKp", XS_main_RPerl_SvUIOKp, file);
        newXS("main::RPerl_SvIOKp", XS_main_RPerl_SvIOKp, file);
        newXS("main::RPerl_SvNOKp", XS_main_RPerl_SvNOKp, file);
        newXS("main::RPerl_SvCOKp", XS_main_RPerl_SvCOKp, file);
        newXS("main::RPerl_SvPOKp", XS_main_RPerl_SvPOKp, file);
        newXS("main::RPerl_SvAROKp", XS_main_RPerl_SvAROKp, file);
        newXS("main::RPerl_SvHROKp", XS_main_RPerl_SvHROKp, file);
        newXS("main::RPerl_object_property_init", XS_main_RPerl_object_property_init, file);
        newXS("main::RPerl__HelperFunctions__MODE_ID", XS_main_RPerl__HelperFunctions__MODE_ID, file);
        newXS("main::RPerl__DataType__Boolean__MODE_ID", XS_main_RPerl__DataType__Boolean__MODE_ID, file);
        newXS("main::XS_unpack_boolean", XS_main_XS_unpack_boolean, file);
        newXS("main::XS_pack_boolean", XS_main_XS_pack_boolean, file);
        newXS("main::boolean_to_integer", XS_main_boolean_to_integer, file);
        newXS("main::boolean_to_number", XS_main_boolean_to_number, file);
        newXS("main::boolean_to_character", XS_main_boolean_to_character, file);
        newXS("main::boolean_to_string", XS_main_boolean_to_string, file);
        newXS("main::boolean__typetest0", XS_main_boolean__typetest0, file);
        newXS("main::boolean__typetest1", XS_main_boolean__typetest1, file);
        newXS("main::RPerl__DataType__UnsignedInteger__MODE_ID", XS_main_RPerl__DataType__UnsignedInteger__MODE_ID, file);
        newXS("main::RPerl__DataType__Integer__MODE_ID", XS_main_RPerl__DataType__Integer__MODE_ID, file);
        newXS("main::XS_unpack_integer", XS_main_XS_unpack_integer, file);
        newXS("main::XS_pack_integer", XS_main_XS_pack_integer, file);
        newXS("main::integer_to_boolean", XS_main_integer_to_boolean, file);
        newXS("main::integer_to_number", XS_main_integer_to_number, file);
        newXS("main::integer_to_character", XS_main_integer_to_character, file);
        newXS("main::integer_to_string", XS_main_integer_to_string, file);
        newXS("main::integer_to_string_CPPTYPES", XS_main_integer_to_string_CPPTYPES, file);
        newXS("main::integer__typetest0", XS_main_integer__typetest0, file);
        newXS("main::integer__typetest1", XS_main_integer__typetest1, file);
        newXS("main::RPerl__DataType__Number__MODE_ID", XS_main_RPerl__DataType__Number__MODE_ID, file);
        newXS("main::XS_unpack_number", XS_main_XS_unpack_number, file);
        newXS("main::XS_pack_number", XS_main_XS_pack_number, file);
        newXS("main::number_to_boolean", XS_main_number_to_boolean, file);
        newXS("main::number_to_integer", XS_main_number_to_integer, file);
        newXS("main::number_to_character", XS_main_number_to_character, file);
        newXS("main::number_to_string", XS_main_number_to_string, file);
        newXS("main::number_to_string_CPPTYPES", XS_main_number_to_string_CPPTYPES, file);
        newXS("main::number__typetest0", XS_main_number__typetest0, file);
        newXS("main::number__typetest1", XS_main_number__typetest1, file);
        newXS("main::RPerl__DataType__Character__MODE_ID", XS_main_RPerl__DataType__Character__MODE_ID, file);
        newXS("main::XS_unpack_character", XS_main_XS_unpack_character, file);
        newXS("main::XS_pack_character", XS_main_XS_pack_character, file);
        newXS("main::character_to_boolean", XS_main_character_to_boolean, file);
        newXS("main::character_to_integer", XS_main_character_to_integer, file);
        newXS("main::character_to_number", XS_main_character_to_number, file);
        newXS("main::character_to_string", XS_main_character_to_string, file);
        newXS("main::character__typetest0", XS_main_character__typetest0, file);
        newXS("main::character__typetest1", XS_main_character__typetest1, file);
        newXS("main::RPerl__DataType__String__MODE_ID", XS_main_RPerl__DataType__String__MODE_ID, file);
        newXS("main::XS_unpack_string", XS_main_XS_unpack_string, file);
        newXS("main::XS_pack_string", XS_main_XS_pack_string, file);
        newXS("main::string_to_boolean", XS_main_string_to_boolean, file);
        newXS("main::string_to_integer", XS_main_string_to_integer, file);
        newXS("main::string_to_number", XS_main_string_to_number, file);
        newXS("main::string_to_character", XS_main_string_to_character, file);
        newXS("main::string_to_string", XS_main_string_to_string, file);
        newXS("main::string__typetest0", XS_main_string__typetest0, file);
        newXS("main::string__typetest1", XS_main_string__typetest1, file);
        newXS("main::integer_arrayref_arrayref_CHECK", XS_main_integer_arrayref_arrayref_CHECK, file);
        newXS("main::integer_arrayref_arrayref_CHECKTRACE", XS_main_integer_arrayref_arrayref_CHECKTRACE, file);
        newXS("main::number_arrayref_arrayref_CHECK", XS_main_number_arrayref_arrayref_CHECK, file);
        newXS("main::number_arrayref_arrayref_CHECKTRACE", XS_main_number_arrayref_arrayref_CHECKTRACE, file);
        newXS("main::string_arrayref_arrayref_CHECK", XS_main_string_arrayref_arrayref_CHECK, file);
        newXS("main::string_arrayref_arrayref_CHECKTRACE", XS_main_string_arrayref_arrayref_CHECKTRACE, file);
        newXS("main::RPerl__DataStructure__Array__SubTypes__MODE_ID", XS_main_RPerl__DataStructure__Array__SubTypes__MODE_ID, file);
        newXS("main::XS_unpack_integer_arrayref_arrayref", XS_main_XS_unpack_integer_arrayref_arrayref, file);
        newXS("main::XS_pack_integer_arrayref_arrayref", XS_main_XS_pack_integer_arrayref_arrayref, file);
        newXS("main::integer_arrayref_arrayref_to_string", XS_main_integer_arrayref_arrayref_to_string, file);
        newXS("main::integer_arrayref_arrayref__typetest0", XS_main_integer_arrayref_arrayref__typetest0, file);
        newXS("main::integer_arrayref_arrayref__typetest1", XS_main_integer_arrayref_arrayref__typetest1, file);
        newXS("main::integer_arrayref_CHECK", XS_main_integer_arrayref_CHECK, file);
        newXS("main::integer_arrayref_CHECKTRACE", XS_main_integer_arrayref_CHECKTRACE, file);
        newXS("main::number_arrayref_CHECK", XS_main_number_arrayref_CHECK, file);
        newXS("main::number_arrayref_CHECKTRACE", XS_main_number_arrayref_CHECKTRACE, file);
        newXS("main::string_arrayref_CHECK", XS_main_string_arrayref_CHECK, file);
        newXS("main::string_arrayref_CHECKTRACE", XS_main_string_arrayref_CHECKTRACE, file);
        newXS("main::RPerl__DataStructure__Array__MODE_ID", XS_main_RPerl__DataStructure__Array__MODE_ID, file);
        newXS("main::XS_unpack_integer_arrayref", XS_main_XS_unpack_integer_arrayref, file);
        newXS("main::XS_pack_integer_arrayref", XS_main_XS_pack_integer_arrayref, file);
        newXS("main::XS_unpack_number_arrayref", XS_main_XS_unpack_number_arrayref, file);
        newXS("main::XS_pack_number_arrayref", XS_main_XS_pack_number_arrayref, file);
        newXS("main::XS_unpack_string_arrayref", XS_main_XS_unpack_string_arrayref, file);
        newXS("main::XS_pack_string_arrayref", XS_main_XS_pack_string_arrayref, file);
        newXS("main::integer_arrayref_to_string", XS_main_integer_arrayref_to_string, file);
        newXS("main::number_arrayref_to_string", XS_main_number_arrayref_to_string, file);
        newXS("main::string_arrayref_to_string", XS_main_string_arrayref_to_string, file);
        newXS("main::integer_arrayref__typetest0", XS_main_integer_arrayref__typetest0, file);
        newXS("main::integer_arrayref__typetest1", XS_main_integer_arrayref__typetest1, file);
        newXS("main::number_arrayref__typetest0", XS_main_number_arrayref__typetest0, file);
        newXS("main::number_arrayref__typetest1", XS_main_number_arrayref__typetest1, file);
        newXS("main::string_arrayref__typetest0", XS_main_string_arrayref__typetest0, file);
        newXS("main::string_arrayref__typetest1", XS_main_string_arrayref__typetest1, file);
        newXS("main::integer_hashref_CHECK", XS_main_integer_hashref_CHECK, file);
        newXS("main::integer_hashref_CHECKTRACE", XS_main_integer_hashref_CHECKTRACE, file);
        newXS("main::number_hashref_CHECK", XS_main_number_hashref_CHECK, file);
        newXS("main::number_hashref_CHECKTRACE", XS_main_number_hashref_CHECKTRACE, file);
        newXS("main::string_hashref_CHECK", XS_main_string_hashref_CHECK, file);
        newXS("main::string_hashref_CHECKTRACE", XS_main_string_hashref_CHECKTRACE, file);
        newXS("main::RPerl__DataStructure__Hash__MODE_ID", XS_main_RPerl__DataStructure__Hash__MODE_ID, file);
        newXS("main::XS_unpack_integer_hashref", XS_main_XS_unpack_integer_hashref, file);
        newXS("main::XS_pack_integer_hashref", XS_main_XS_pack_integer_hashref, file);
        newXS("main::XS_unpack_number_hashref", XS_main_XS_unpack_number_hashref, file);
        newXS("main::XS_pack_number_hashref", XS_main_XS_pack_number_hashref, file);
        newXS("main::XS_unpack_string_hashref", XS_main_XS_unpack_string_hashref, file);
        newXS("main::XS_pack_string_hashref", XS_main_XS_pack_string_hashref, file);
        newXS("main::integer_hashref_to_string", XS_main_integer_hashref_to_string, file);
        newXS("main::number_hashref_to_string", XS_main_number_hashref_to_string, file);
        newXS("main::string_hashref_to_string", XS_main_string_hashref_to_string, file);
        newXS("main::integer_hashref__typetest0", XS_main_integer_hashref__typetest0, file);
        newXS("main::integer_hashref__typetest1", XS_main_integer_hashref__typetest1, file);
        newXS("main::number_hashref__typetest0", XS_main_number_hashref__typetest0, file);
        newXS("main::number_hashref__typetest1", XS_main_number_hashref__typetest1, file);
        newXS("main::string_hashref__typetest0", XS_main_string_hashref__typetest0, file);
        newXS("main::string_hashref__typetest1", XS_main_string_hashref__typetest1, file);
        newXS("main::to_number", XS_main_to_number, file);
        newXS("main::To_string", XS_main_To_string, file);
        newXS("main::RPerl__diag", XS_main_RPerl__diag, file);
        newXS("main::RPerl__verbose", XS_main_RPerl__verbose, file);
        newXS("main::RPerl__warning", XS_main_RPerl__warning, file);
        newXS("main::RPerl__MODE_ID", XS_main_RPerl__MODE_ID, file);
        newXS("main::classname", XS_main_classname, file);
        newXS("main::MathPerl__Operation__MODE_ID", XS_main_MathPerl__Operation__MODE_ID, file);
        newXS("main::MathPerl__DataStructure__MODE_ID", XS_main_MathPerl__DataStructure__MODE_ID, file);
        newXS("main::MathPerl__DataStructure__Vector__Vector_to_string", XS_main_MathPerl__DataStructure__Vector__Vector_to_string, file);
        newXS("main::MathPerl__DataStructure__Vector__MODE_ID", XS_main_MathPerl__DataStructure__Vector__MODE_ID, file);
        newXS("main::MathPerl__Arithmetic__ApproximatelyEqual__approximately_equal", XS_main_MathPerl__Arithmetic__ApproximatelyEqual__approximately_equal, file);
        newXS("main::MathPerl__Arithmetic__ApproximatelyEqual__MODE_ID", XS_main_MathPerl__Arithmetic__ApproximatelyEqual__MODE_ID, file);
        newXS("main::MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw", XS_main_MathPerl__LinearAlgebra__AddVectorVector__add_vector_vector_raw, file);
        newXS("main::MathPerl__LinearAlgebra__AddVectorVector__MODE_ID", XS_main_MathPerl__LinearAlgebra__AddVectorVector__MODE_ID, file);

    /* Initialisation Section */

#line 4395 "eval_511_6b51.xs"
{
#ifndef get_av
    AV *isa = perl_get_av("MathPerl::Operation::ISA", 1);
#else
    AV *isa = get_av("MathPerl::Operation::ISA", 1);
#endif
    av_push(isa, newSVpv("RPerl::CompileUnit::Module::Class::CPP", 0));
}
{
#ifndef get_av
    AV *isa = perl_get_av("MathPerl::DataStructure::ISA", 1);
#else
    AV *isa = get_av("MathPerl::DataStructure::ISA", 1);
#endif
    av_push(isa, newSVpv("RPerl::CompileUnit::Module::Class::CPP", 0));
}
{
#ifndef get_av
    AV *isa = perl_get_av("MathPerl::DataStructure::Vector::ISA", 1);
#else
    AV *isa = get_av("MathPerl::DataStructure::Vector::ISA", 1);
#endif
    av_push(isa, newSVpv("MathPerl::DataStructure", 0));
}
{
#ifndef get_av
    AV *isa = perl_get_av("MathPerl::Arithmetic::ApproximatelyEqual::ISA", 1);
#else
    AV *isa = get_av("MathPerl::Arithmetic::ApproximatelyEqual::ISA", 1);
#endif
    av_push(isa, newSVpv("MathPerl::Operation", 0));
}
{
#ifndef get_av
    AV *isa = perl_get_av("MathPerl::LinearAlgebra::AddVectorVector::ISA", 1);
#else
    AV *isa = get_av("MathPerl::LinearAlgebra::AddVectorVector::ISA", 1);
#endif
    av_push(isa, newSVpv("MathPerl::Operation", 0));
}

#line 7145 "eval_511_6b51.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

